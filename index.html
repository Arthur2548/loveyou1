<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Royal Family Tree (Enhanced Lineage & Surnames)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;700&family=Mali:wght@400;600&family=Chakra+Petch:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* ================= THEME VARIABLES ================= */
        :root {
            --bg-main: #f8fafc;
            --bg-dots: #e2e8f0;
            --text-main: #334155;
            --text-sub: #64748b;
            --primary: #475569;
            --primary-light: #94a3b8;
            --accent-bg: #ffffff;
            --accent-border: #e2e8f0;
            --card-shadow: rgba(0, 0, 0, 0.05);
            /* New Themed Line Colors */
            --line-color-child: #94a3b8; /* Slate */
            --line-color-spouse: #fca5a5; /* Red (light) */
            --line-width: 1.5px;
            --heart-color: #ef4444;
        }

        /* Themes */
        [data-theme="pink"] { 
            --bg-main: #fff0f5; --bg-dots: #fbcfe8; --text-main: #831843; --text-sub: #be185d; 
            --primary: #ec4899; --primary-light: #f9a8d4; --accent-bg: #fff; 
            --accent-border: #fbcfe8; 
            --line-color-child: #f472b6; /* Pink */
            --line-color-spouse: #34d399; /* Green for contrast */
        }
        [data-theme="purple"] { 
            --bg-main: #faf5ff; --bg-dots: #e9d5ff; --text-main: #581c87; --text-sub: #7e22ce; 
            --primary: #a855f7; --primary-light: #d8b4fe; --accent-bg: #fff; 
            --accent-border: #e9d5ff; 
            --line-color-child: #c084fc; /* Purple */
            --line-color-spouse: #fcd34d; /* Yellow for contrast */
        }
        [data-theme="yellow"] { 
            --bg-main: #fffbeb; --bg-dots: #fde68a; --text-main: #78350f; --text-sub: #b45309; 
            --primary: #f59e0b; --primary-light: #fcd34d; --accent-bg: #fff; 
            --accent-border: #fde68a; 
            --line-color-child: #fbbf24; /* Amber */
            --line-color-spouse: #38bdf8; /* Blue for contrast */
        }
        [data-theme="blue"] { 
            --bg-main: #f0f9ff; --bg-dots: #bae6fd; --text-main: #0c4a6e; --text-sub: #0284c7; 
            --primary: #0ea5e9; --primary-light: #7dd3fc; --accent-bg: #fff; 
            --accent-border: #bae6fd; 
            --line-color-child: #38bdf8; /* Blue */
            --line-color-spouse: #f472b6; /* Pink for contrast */
        }

        /* ================= GENERAL STYLES ================= */
        body {
            font-family: 'Sarabun', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s;
        }

        h1, h2, h3, .font-cute { font-family: 'Mali', cursive; }
        .font-royal { font-family: 'Chakra Petch', sans-serif; }

        
        /* ================= CANVAS AREA (SVG) ================= */
        #canvas-container {
            flex: 1;
            position: relative;
            cursor: grab;
            background-color: var(--bg-main);
            background-image: radial-gradient(var(--bg-dots) 1px, transparent 1px);
            background-size: 24px 24px;
            overflow: hidden;
        }
        #canvas-container:active { cursor: grabbing; }

        #main-svg { width: 100%; height: 100%; display: block; }

        /* Nodes inside SVG */
        .node-box {
            width: 100%; height: 100%;
            background: var(--accent-bg);
            backdrop-filter: blur(8px);
            border-radius: 16px;
            padding: 8px 6px;
            box-shadow: 0 4px 15px -3px var(--card-shadow);
            border-width: 2px;
            border-style: solid;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-sizing: border-box;
            position: relative;
        }
        .node-box:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 15px 30px -5px rgba(0,0,0,0.15); z-index: 10; border-color: var(--primary); }
        
        /* Focused & Highlight Animation */
        .node-box.focused { box-shadow: 0 0 0 4px var(--primary-light); }
        
        .node-flash {
            animation: flash-highlight 1.5s infinite ease-in-out;
            border-color: #ef4444 !important;
            border-width: 3px !important;
            z-index: 50;
        }

        @keyframes flash-highlight {
            0% { box-shadow: 0 0 0 0px rgba(239, 68, 68, 0.7); transform: scale(1); }
            50% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); transform: scale(1.05); }
            100% { box-shadow: 0 0 0 0px rgba(239, 68, 68, 0); transform: scale(1); }
        }

        /* Status Borders */
        .border-male { border-color: #38bdf8; } 
        .border-female { border-color: #c084fc; } 
        .border-king { border-color: #fbbf24; background: linear-gradient(to bottom, #fff, #fffbeb); } 
        .border-queen { border-color: #f472b6; background: linear-gradient(to bottom, #fff, #fff0f5); } 
        
        /* Death Visuals */
        .border-dead { filter: grayscale(1) opacity(0.8); border-style: dashed !important; border-color: #64748b !important; }
        
        /* Monarch Death: Black Border, Normal Image */
        .border-dead-royal { 
            border-color: #000000 !important; 
            border-width: 3px !important;
            background: #f8f8f8;
        }
        
        .img-grayscale { filter: grayscale(1); }
        .img-normal { filter: none; }

        /* Connectors (Updated for Themed Lines) */
        .connector { fill: none; stroke-width: var(--line-width); transition: stroke 0.3s; }
        .connector-child { stroke: var(--line-color-child); } /* New: Color for parent-child connection */
        .connector-spouse { stroke: var(--line-color-spouse); } /* New: Color for spouse connection */
        .connector:hover { stroke: var(--primary); stroke-width: 2.5px; }
        .heart-icon { font-size: 14px; fill: var(--heart-color); filter: drop-shadow(0px 1px 2px rgba(255, 255, 255, 0.8)); }

        /* Ancestor Label */
        .ancestor-label {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--primary);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-weight: bold;
            z-index: 5;
        }

        /* ================= TABLE VIEW ================= */
        .table-view-container {
            background-color: var(--bg-main);
            overflow-y: auto;
            flex: 1;
            padding: 2rem;
        }
        .table-wrapper {
             overflow-x: auto; /* Ensure horizontal scrolling for table */
        }
        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        th { color: var(--text-sub); font-weight: 600; padding: 12px; font-size: 14px; border-bottom: 2px solid var(--accent-border); white-space: nowrap; text-align: left; }
        td { padding: 12px; border-bottom: 1px solid var(--accent-border); background: var(--accent-bg); color: var(--text-main); font-size: 14px; vertical-align: middle; }
        tr.data-row:hover td { background-color: var(--bg-dots); cursor: pointer; }
        tr.data-row:first-child td:first-child { border-top-left-radius: 16px; }
        tr.data-row:first-child td:last-child { border-top-right-radius: 16px; }
        tr.data-row:last-child td:first-child { border-bottom-left-radius: 16px; }
        tr.data-row:last-child td:last-child { border-bottom-right-radius: 16px; }

        /* NEW: Glowing tags for table view */
        .monarch-tag-table { 
            background-color: #fffbeb; 
            color: #a16207; 
            border: 1px solid #fcd34d; 
            padding: 1px 6px; 
            border-radius: 6px; 
            font-size: 10px; 
            font-weight: bold; 
            box-shadow: 0 0 8px rgba(253, 211, 77, 0.6); 
            display: inline-flex; 
            align-items: center; 
            margin-left: 8px;
            white-space: nowrap;
        }
        .queen-consort-tag-table {
            background-color: #fce7f3; /* Light pink */
            color: #be185d; /* Darker pink */
            border: 1px solid #fbcfe8;
            padding: 1px 6px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: bold;
            box-shadow: 0 0 8px rgba(251, 207, 232, 0.6); 
            display: inline-flex; 
            align-items: center; 
            margin-left: 8px;
            white-space: nowrap;
        }
        .heir-tag-table {
            background-color: #fee2e2; /* Light red */
            color: #991b1b; /* Darker red */
            border: 1px solid #fecaca;
            padding: 1px 6px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: bold;
            box-shadow: 0 0 8px rgba(254, 202, 202, 0.6); 
            display: inline-flex; 
            align-items: center; 
            margin-left: 8px;
            white-space: nowrap;
        }
        /* ================= UI CONTROLS ================= */
        .floating-controls {
            position: absolute; bottom: 24px; right: 24px;
            display: flex; flex-direction: column; gap: 8px; z-index: 50;
        }
        .ctrl-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--accent-bg); border: 1px solid var(--accent-border);
            color: var(--primary); display: flex; align-items: center; justify-content: center;
            cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: all 0.2s;
        }
        .ctrl-btn:hover { transform: scale(1.1); background: var(--bg-dots); }

        .btn-theme { background-color: var(--primary); color: white; border-radius: 50px; font-weight: 600; padding: 6px 16px; font-size: 12px; transition: all 0.2s; }
        .btn-theme:hover { filter: brightness(1.1); transform: translateY(-1px); }
        
        .btn-icon { background: var(--accent-bg); border: 1px solid var(--accent-border); color: var(--primary); border-radius: 50%; transition: all 0.2s; }
        .btn-icon:hover { background: var(--bg-dots); transform: scale(1.1); }

        .input-theme { background: var(--accent-bg); border: 1px solid var(--accent-border); color: var(--text-main); border-radius: 12px; padding: 8px; outline: none; }
        .input-theme:focus { border-color: var(--primary); box-shadow: 0 0 0 2px var(--bg-dots); }

        /* Modals */
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); justify-content: center; align-items: center; }
        .modal.active { display: flex; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content { background: var(--accent-bg); border: 1px solid var(--accent-border); border-radius: 24px; box-shadow: 0 20px 60px -10px rgba(0,0,0,0.2); }

        /* Fantasy Celebration Modal */
        #fantasyModal .modal-content {
            background: linear-gradient(135deg, #1a0b00 0%, #4a2c0a 100%);
            border: 2px solid #d4af37;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.3), inset 0 0 30px rgba(0,0,0,0.8);
            color: #f3e5ab;
            max-width: 500px;
            text-align: center;
            position: relative;
            overflow: hidden;
            padding: 40px 20px;
        }
        .golden-frame {
            border: 3px double #d4af37;
            padding: 4px;
            display: inline-block;
            border-radius: 50%;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            background: #000;
        }
        .shimmer-text {
            background: linear-gradient(to right, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-weight: bold;
            animation: shimmer 3s infinite linear;
            background-size: 200% auto;
        }
        @keyframes shimmer { to { background-position: 200% center; } }
        .particle { position: absolute; background: #ffd700; border-radius: 50%; opacity: 0; animation: rise 4s infinite ease-in; }
        @keyframes rise { 0% { bottom: -10px; opacity: 0; transform: scale(0); } 50% { opacity: 1; } 100% { bottom: 100%; opacity: 0; transform: scale(1); } }

        /* Toast */
        #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 200; pointer-events: none; }
        .toast { background: #334155; color: white; padding: 8px 16px; border-radius: 20px; font-size: 12px; margin-top: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: slideUp 0.3s ease-out; opacity: 0.9; }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 0.9; } }

        /* Monarch Banner */
        .monarch-frame { border: 2px solid #fbbf24; background: linear-gradient(to right, #fffbeb, #fff); box-shadow: 0 4px 6px rgba(251, 191, 36, 0.2); }
        
        /* Badges for Tree */
        .badge-monarch { background-color: #fef9c3; color: #854d0e; border: 1px solid #fde047; padding: 1px 4px; border-radius: 4px; font-size: 8px; font-weight: bold; margin-top: 2px; }
        .badge-krom { background-color: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; padding: 1px 4px; border-radius: 4px; font-size: 8px; font-weight: bold; margin-top: 2px; }
        .badge-heir { background-color: #fee2e2; color: #991b1b; border: 1px solid #fecaca; padding: 1px 4px; border-radius: 4px; font-size: 8px; font-weight: bold; margin-top: 2px; }

        /* Kingdom Selector */
        .kingdom-selector {
            background: white;
            border: 1px solid var(--accent-border);
            border-radius: 12px;
            padding: 4px 8px;
            font-size: 14px;
            outline: none;
            color: var(--text-main);
            max-width: 200px;
            font-weight: bold;
        }

        /* View Mode Selector */
        .view-mode-selector {
            background: var(--accent-bg);
            color: var(--primary);
            border: 1px solid var(--accent-border);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            outline: none;
            cursor: pointer;
            text-align: center;
            appearance: none;
        }
        .view-mode-wrapper { position: relative; }
        .view-mode-wrapper::after {
            content: '\f0d7';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--primary);
            pointer-events: none;
            font-size: 10px;
        }
    </style>
</head>
<body>

    <!-- Header -->
    <header class="sticky top-0 z-40 px-4 py-3" style="background-color: rgba(255,255,255,0.8); backdrop-filter: blur(10px); border-bottom: 1px solid var(--accent-border);">
        <div class="container mx-auto flex flex-col md:flex-row justify-between items-center gap-3">
            <div class="flex items-center space-x-3 w-full md:w-auto">
                <div class="w-10 h-10 rounded-full flex items-center justify-center shadow-md text-white flex-shrink-0" style="background: var(--primary);">
                    <i class="fa-solid fa-chess-king"></i>
                </div>
                <div class="flex flex-col min-w-0 flex-1">
                    <!-- Multi-Kingdom Selector -->
                    <div class="flex items-center gap-2">
                        <select id="kingdomSelector" class="kingdom-selector" onchange="switchKingdom(this.value)"></select>
                        <button onclick="deleteCurrentKingdom()" class="w-6 h-6 flex items-center justify-center rounded-full text-red-400 hover:bg-red-50" title="ลบอาณาจักรนี้"><i class="fa-solid fa-trash text-xs"></i></button>
                        <button onclick="openCreateKingdomModal()" class="w-6 h-6 flex items-center justify-center rounded-full text-emerald-500 hover:bg-emerald-50" title="สร้างอาณาจักรใหม่"><i class="fa-solid fa-plus text-xs"></i></button>
                    </div>
                    <p id="dynastyLabel" class="text-[10px] text-slate-400 truncate"></p>
                </div>
            </div>
            
            <div class="flex flex-wrap gap-2 items-center justify-center md:justify-end w-full">
                <!-- Theme Switcher -->
                <div class="flex gap-1.5 bg-white px-3 py-1.5 rounded-full shadow-sm border border-slate-100">
                    <button onclick="setTheme('white')" class="w-4 h-4 rounded-full border border-gray-300 bg-gray-50"></button>
                    <button onclick="setTheme('pink')" class="w-4 h-4 rounded-full border border-pink-300 bg-pink-400"></button>
                    <button onclick="setTheme('purple')" class="w-4 h-4 rounded-full border border-purple-300 bg-purple-400"></button>
                    <button onclick="setTheme('yellow')" class="w-4 h-4 rounded-full border border-yellow-300 bg-yellow-400"></button>
                    <button onclick="setTheme('blue')" class="w-4 h-4 rounded-full border border-blue-300 bg-blue-400"></button>
                </div>

                <!-- View Switcher -->
                <div class="flex bg-white/50 p-1 rounded-full border border-slate-200">
                    <button onclick="switchView('tree')" id="btn-view-tree" class="px-3 py-1 text-xs rounded-full transition font-bold" style="background: var(--primary); color: white;">
                        <i class="fa-solid fa-sitemap mr-1"></i> ผัง
                    </button>
                    <button onclick="switchView('table')" id="btn-view-table" class="px-3 py-1 text-xs rounded-full transition text-slate-500 hover:text-slate-700">
                        <i class="fa-solid fa-table mr-1"></i> ตาราง
                    </button>
                </div>

                <!-- Find Relationship -->
                <button onclick="openRelationshipModal()" class="btn-theme flex items-center space-x-2" title="ค้นหาความสัมพันธ์">
                    <i class="fa-solid fa-users-rays"></i> <span class="hidden lg:inline">ค้นหาความสัมพันธ์</span>
                </button>

                <!-- Focus Search -->
                <div class="relative">
                    <input type="text" id="focusSearch" list="focusOptions" placeholder="ค้นหาบุคคล..." class="pl-8 pr-3 py-1.5 text-xs rounded-full border border-slate-200 focus:border-primary focus:ring-1 focus:ring-primary outline-none bg-white/80 w-32 transition-all focus:w-48" onchange="focusOnPerson(this.value)">
                    <i class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 text-xs"></i>
                    <datalist id="focusOptions"></datalist>
                </div>

                <!-- Actions -->
                <button onclick="openRankManagementModal()" class="btn-icon w-9 h-9 flex items-center justify-center shadow-sm" title="จัดการยศ"><i class="fa-solid fa-sliders"></i></button>
                
                <button onclick="openAddRootModal()" class="btn-theme flex items-center space-x-2"><i class="fa-solid fa-user-plus"></i><span class="hidden sm:inline">เพิ่มคนแรก</span></button>

                <!-- Monarch Banner (Fixed Visibility) -->
                <div id="monarchBannerContainer" class="flex items-center">
                    <!-- Active Monarch -->
                    <div id="monarchBanner" class="hidden monarch-frame rounded-full pl-1 pr-4 py-1 flex items-center gap-2 transition-all duration-500 cursor-pointer hover:scale-105" onclick="focusOnMonarch()">
                        <div class="relative">
                            <img id="monarchImg" src="" class="w-9 h-9 rounded-full border-2 border-white shadow-sm object-cover">
                            <i class="fa-solid fa-crown text-[10px] text-yellow-500 absolute -top-1 -right-1 bg-white rounded-full p-0.5 shadow-sm"></i>
                        </div>
                        <div class="text-xs text-left hidden lg:block">
                            <div class="text-[9px] text-amber-600 font-bold uppercase tracking-wide">พระมหากษัตริย์</div>
                            <div id="monarchName" class="font-bold leading-none text-slate-800 text-[11px]">-</div>
                        </div>
                    </div>
                    <!-- Vacant Throne -->
                    <div id="monarchVacant" class="hidden bg-red-50 border border-red-200 text-red-600 rounded-full px-3 py-1 flex items-center gap-2 text-xs shadow-sm animate-pulse">
                        <i class="fa-solid fa-triangle-exclamation"></i>
                        <span class="font-bold hidden md:inline">บัลลังก์ว่าง</span>
                        <button onclick="openAppointModal()" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded-full font-bold shadow-sm transition text-[10px]">สถาปนา</button>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 relative overflow-hidden flex flex-col">
        <!-- Tree View -->
        <div id="canvas-container" class="flex-1">
            <svg id="main-svg">
                <g id="viewport-group">
                    <g id="links-layer"></g>
                    <g id="nodes-layer"></g>
                </g>
            </svg>
            
            <div id="empty-state" class="hidden absolute inset-0 flex flex-col items-center justify-center pointer-events-none">
                <div class="bg-white/80 backdrop-blur p-6 rounded-2xl shadow-xl text-center max-w-sm pointer-events-auto border-2 border-dashed border-slate-300">
                    <div class="text-4xl mb-4 text-slate-300"><i class="fa-solid fa-sitemap"></i></div>
                    <h3 class="text-lg font-bold text-slate-700 mb-2">ยังไม่มีข้อมูลในราชวงศ์นี้</h3>
                    <button onclick="openAddRootModal()" class="btn-theme w-full">สร้างบุคคลแรก</button>
                </div>
            </div>

            <div class="floating-controls">
                <div class="view-mode-wrapper">
                    <select id="treeViewMode" class="view-mode-selector" onchange="changeViewMode(this.value)">
                        <option value="all">1. ภาพรวมทั้งหมด</option>
                        <option value="descendants">2. สายสกุล (ลูกหลาน)</option>
                        <option value="direct">3. สายตรง (บรรพบุรุษ+ลูกหลาน)</option>
                        <option value="ancestors">4. สายบรรพบุรุษ (Ancestors)</option>
                        <option value="royalSurname">5. มุมมองสายราชสกุล</option>
                    </select>
                </div>

                <!-- NEW: Reign Filter Dropdown for Royal Surname View -->
                <select id="reignFilterSelector" class="view-mode-selector hidden" onchange="changeRoyalSurnameFilter(this.value)">
                    <option value="all">กรองตามเชื้อสายรัชกาล... (ทั้งหมด)</option>
                    <!-- Options populated by JS -->
                </select>

                <!-- Royal Surname Selector/Header -->
                <select id="royalSurnameSelector" class="view-mode-selector hidden" onchange="changeRoyalSurnameRoot(this.value)">
                    <!-- Options populated by JS -->
                </select>
                
                <div id="surnameViewHeader" class="bg-white/90 p-2 rounded-xl text-center shadow-md hidden">
                     <div class="text-[10px] text-slate-500">หัวผังสายราชสกุล</div>
                     <div id="surnameHeaderName" class="font-bold text-sm text-indigo-600">ราชสกุล.</div>
                </div>

                <div class="h-px w-20 bg-slate-300 mx-auto my-1"></div>
                <button class="ctrl-btn" onclick="toggleOrientation()" title="สลับแนว (ตั้ง/นอน)"><i class="fa-solid fa-rotate"></i></button>
                <button class="ctrl-btn" onclick="zoomIn()"><i class="fa-solid fa-plus"></i></button>
                <button class="ctrl-btn" onclick="zoomOut()"><i class="fa-solid fa-minus"></i></button>
                <button class="ctrl-btn" onclick="resetView()"><i class="fa-solid fa-crosshairs"></i></button>
            </div>
        </div>

        <!-- Table View -->
        <div id="tableView" class="table-view-container hidden">
            <div class="container mx-auto max-w-5xl">
                <div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
                    <h2 class="font-cute text-2xl" style="color: var(--primary);">รายชื่อสมาชิก</h2>
                    
                    <!-- ส่วนควบคุมตาราง -->
                    <div class="flex gap-2 items-center flex-wrap justify-center">
                        <!-- ปุ่มรีเซ็ตลำดับ -->
                        <button id="btnResetPrecedence" onclick="resetPrecedence()" class="hidden bg-red-50 hover:bg-red-100 text-red-500 px-3 py-1.5 rounded-full text-xs font-bold transition border border-red-100" title="คืนค่าลำดับตามกฎปกติ">
                            <i class="fa-solid fa-rotate-left mr-1"></i> รีเซ็ตลำดับ
                        </button>
                    
                        <select id="tableFilterStatus" class="bg-white px-4 py-1.5 rounded-full border border-slate-200 text-sm focus:border-primary focus:ring-1 focus:ring-primary outline-none transition cursor-pointer" onchange="renderTable()">
                            <option value="all">แสดงทั้งหมด</option>
                            <option value="alive" selected>เฉพาะผู้มีชีวิต</option>
                            <option value="dead">เฉพาะผู้เสียชีวิต</option>
                            <option value="precedence">✨ เรียงตามลำดับโปเจียม</option>
                        </select>
                    
                        <div class="relative group">
                            <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                <i class="fa-solid fa-search text-slate-400 group-focus-within:text-primary transition"></i>
                            </div>
                            <input type="text" id="tableSearch" oninput="renderTable()" placeholder="ค้นหาชื่อ, ฉายา..." class="pl-10 pr-4 py-1.5 rounded-full border border-slate-200 text-sm focus:border-primary focus:ring-2 focus:ring-blue-100 outline-none transition w-64 bg-white shadow-sm">
                        </div>
                    </div>
                    <!-- จบส่วนควบคุมตาราง -->

                </div>
                <div class="rounded-[20px] shadow-sm border overflow-hidden" style="background: var(--accent-bg); border-color: var(--accent-border);">
                    <div class="table-wrapper"> <!-- ADDED WRAPPER FOR SCROLL -->
                        <table class="w-full text-left">
                            <thead>
                                <tr style="background: var(--bg-dots);">
                                    <th class="text-center w-20">รูป</th>
                                    <th>พระนาม / นาม</th>
                                    <th>สถานะ</th>
                                    <th>บิดา / มารดา</th>
                                    <th class="text-center">จัดการ</th>
                                </tr>
                            </thead>
                            <tbody id="tableBody"></tbody>
                        </table>
                    </div> <!-- END WRAPPER -->
                </div>
            </div>
        </div>
    </main>

    <!-- Detail Modal -->
    <div id="detailModal" class="modal">
        <div class="modal-content w-full max-w-sm overflow-hidden relative border-4 border-white">
            <button onclick="closeModal('detailModal')" class="absolute top-3 right-3 text-white bg-black/10 rounded-full w-8 h-8 z-20 hover:bg-black/20 backdrop-blur-sm flex items-center justify-center transition">✕</button>
            
            <div class="h-48 relative overflow-hidden" style="background: linear-gradient(to top right, var(--bg-dots), var(--primary-light));">
                <div class="absolute inset-0 opacity-30 mix-blend-overlay bg-[url('https://www.transparenttextures.com/patterns/cubes.png')]"></div>
                <div class="absolute -bottom-10 left-1/2 -translate-x-1/2 flex flex-col items-center">
                    <div class="relative">
                        <img id="d_img" class="w-28 h-28 rounded-full border-[4px] border-white bg-white object-cover shadow-lg aspect-square">
                        <i id="d_crown" class="fa-solid fa-crown absolute -top-6 left-1/2 -translate-x-1/2 text-3xl text-yellow-400 drop-shadow-md hidden filter saturate-150 animate-pulse"></i>
                    </div>
                </div>
            </div>

            <div class="pt-14 pb-8 px-6 text-center" style="background: var(--accent-bg);">
                <h3 id="d_name" class="text-lg font-royal font-bold leading-tight mb-1" style="color: var(--text-main);"></h3>
                <div class="flex justify-center items-center gap-2 mb-3">
                    <div class="text-[10px] font-mono bg-gray-100 px-2 py-0.5 rounded text-gray-500 flex items-center gap-1 cursor-pointer hover:bg-gray-200 transition" onclick="copyToClipboard(window.curPID)">
                        <span id="d_id"></span> <i class="fa-regular fa-copy"></i>
                    </div>
                </div>
                
                <p id="d_krom" class="text-xs font-bold text-amber-600 bg-amber-50 inline-block px-4 py-1.5 rounded-xl mb-4 border border-amber-200 shadow-sm hidden"></p>

                <div id="d_badges" class="flex flex-wrap justify-center gap-2 mb-4"></div>

                <div class="grid grid-cols-1 gap-2 mb-4">
                    <button onclick="setAsRoot(window.curPID)" class="w-full py-2 bg-indigo-500 hover:bg-indigo-600 text-white rounded-xl text-xs font-bold shadow-sm transition flex items-center justify-center gap-2">
                        <i class="fa-solid fa-sitemap"></i> ดูผังพงศาวลีของคนนี้
                    </button>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="openSpouseSelectionModal(window.curPID)" class="py-2 bg-pink-500 hover:bg-pink-600 text-white rounded-xl text-xs font-bold shadow-sm transition flex items-center justify-center gap-2">
                            <i class="fa-solid fa-heart"></i> เพิ่มคู่สมรส
                        </button>
                        <button onclick="openAddChildModal(window.curPID)" class="py-2 bg-emerald-500 hover:bg-emerald-600 text-white rounded-xl text-xs font-bold shadow-sm transition flex items-center justify-center gap-2">
                            <i class="fa-solid fa-baby"></i> เพิ่มลูก
                        </button>
                    </div>
                    <button onclick="showHistoryModal(window.curPID)" class="w-full py-2 bg-slate-700 hover:bg-slate-800 text-white rounded-xl text-xs font-bold shadow-sm transition flex items-center justify-center gap-2 mb-2">
    <i class="fa-solid fa-scroll"></i> ทำเนียบพระยศ
</button>
                    <button onclick="openAddParentModal(window.curPID)" class="w-full py-2 bg-amber-500 hover:bg-amber-600 text-white rounded-xl text-xs font-bold shadow-sm transition flex items-center justify-center gap-2">
                        <i class="fa-solid fa-arrow-up"></i> เพิ่มพระบิดา/พระมารดา
                    </button>
                </div>

                <div id="d_statusBox" class="text-left text-sm space-y-2 p-4 rounded-3xl border shadow-inner mb-4" style="background: var(--bg-main); border-color: var(--accent-border);">
                    <div class="flex justify-between"><span class="text-xs text-slate-400">สถานะ</span><span id="d_status" class="font-bold"></span></div>
                    <!-- NEW: Display Birth Year -->
                    <div class="flex justify-between"><span class="text-xs text-slate-400">วันประสูติ (พ.ศ.)</span><span id="d_birthYear"></span></div>
                    <div class="flex justify-between"><span class="text-xs text-slate-400">คู่สมรส</span><span id="d_spouses_count"></span></div>
                    <div class="flex justify-between"><span class="text-xs text-slate-400">ฉัตร</span><span id="d_umbrella"></span></div>
                </div>

                <!-- UPDATED BUTTONS BLOCK: King will always have 4 buttons (Edit, Abdicate, Death, Delete) -->
                <div class="flex gap-2 justify-center border-t pt-4 border-slate-100">
                    <button onclick="editCurrent()" class="btn-icon w-10 h-10 flex items-center justify-center text-lg" title="แก้ไข"><i class="fa-solid fa-pen"></i></button>
                    
                    <!-- Abdicate Button (Only visible for active monarch) -->
                    <button onclick="abdicateCurrent()" id="btnAbdicate" class="btn-icon w-10 h-10 flex items-center justify-center text-lg text-purple-600 hover:text-purple-700 hidden" title="สละราชสมบัติ">
                        <i class="fa-solid fa-person-walking-arrow-right"></i>
                    </button>

                    <!-- Death Button (Always visible) -->
                    <button onclick="toggleDeath()" id="btnDeath" class="btn-icon w-10 h-10 flex items-center justify-center text-lg" title="แจ้งตาย/คืนชีพ"><i class="fa-solid fa-skull"></i></button>
                    
                    <button onclick="deleteCurrent()" class="btn-icon w-10 h-10 flex items-center justify-center text-lg text-red-400" title="ลบ"><i class="fa-solid fa-trash"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Person Form Modal -->
    <div id="personModal" class="modal">
         <div class="modal-content w-full max-w-4xl max-h-[90vh] flex flex-col overflow-hidden">
            <div class="flex justify-between items-center p-5 border-b" style="background: var(--bg-dots);">
                <h2 id="modalTitle" class="font-cute font-bold text-lg"><i class="fa-solid fa-wand-magic-sparkles mr-2"></i>ข้อมูลบุคคล</h2>
                <button onclick="closeModal('personModal')" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-red-50 hover:text-red-400 transition"><i class="fa-solid fa-times"></i></button>
            </div>
            <div class="p-6 overflow-y-auto custom-scrollbar flex-1" style="background: var(--accent-bg);">
                <form id="personForm" onsubmit="handleSavePerson(event)" class="space-y-6">
                    <input type="hidden" id="p_isEditMode">
                    <div class="flex gap-8 flex-col md:flex-row">
                        <!-- Image Upload -->
                        <div class="flex-shrink-0 flex flex-col items-center gap-3">
                            <div class="w-36 h-36 rounded-full border-4 flex items-center justify-center overflow-hidden relative group cursor-pointer transition shadow-sm" style="background: var(--bg-dots);" onclick="document.getElementById('p_imageFile').click()">
                                <img id="p_imagePreview" class="w-full h-full object-cover">
                                <div class="absolute inset-0 bg-black/20 flex items-center justify-center opacity-0 group-hover:opacity-100 text-white transition backdrop-blur-sm"><i class="fa-solid fa-camera text-2xl"></i></div>
                            </div>
                            <input type="file" id="p_imageFile" accept="image/*" class="hidden" onchange="handleImageUpload(this)"><input type="hidden" id="p_imageFinal">
                            <div class="flex gap-2">
                                <label class="cursor-pointer bg-blue-50 text-blue-500 px-4 py-1.5 rounded-full text-xs font-bold border border-blue-100 peer-checked:bg-blue-400 peer-checked:text-white transition"><input type="radio" name="gender" value="M" checked class="hidden" onchange="updateDefaultImage(); checkQueenConsortEligible(); updateAutoId();"> ชาย</label>
                                <label class="cursor-pointer bg-pink-50 text-pink-500 px-4 py-1.5 rounded-full text-xs font-bold border border-pink-100 peer-checked:bg-pink-400 peer-checked:text-white transition"><input type="radio" name="gender" value="F" class="hidden" onchange="updateDefaultImage(); checkQueenConsortEligible(); updateAutoId();"> หญิง</label>
                            </div>
                            <label class="flex items-center gap-2 cursor-pointer bg-emerald-50 px-3 py-1 rounded-full border border-emerald-100">
                                <input type="checkbox" id="p_isAlive" checked class="accent-emerald-500 rounded"> <span class="text-xs text-emerald-600 font-bold">มีชีวิตอยู่</span>
                            </label>
                        </div>
                        <!-- Info Fields -->
                        <div class="flex-1 space-y-4">
                            <div class="flex gap-2 items-end bg-slate-50 p-2 rounded-lg border border-slate-100">
                                <div class="flex-1">
                                    <label class="text-xs font-bold text-slate-500">ID (อัตโนมัติ)</label>
                                    <input type="text" id="p_id" readonly class="w-full text-sm font-mono bg-transparent border-none focus:ring-0 text-slate-600">
                                </div>
                                <button type="button" onclick="copyToClipboard(document.getElementById('p_id').value)" class="p-1.5 text-xs bg-white border rounded shadow-sm hover:bg-slate-50">คัดลอก</button>
                            </div>
                            <div class="p-4 rounded-[25px] border grid grid-cols-1 md:grid-cols-2 gap-4" style="background: var(--bg-dots);">
                                <div>
                                    <label class="text-xs font-bold text-indigo-400 mb-1 block ml-2">พระบิดา</label>
                                    <div class="flex gap-1 relative">
                                        <input type="text" id="p_fatherSearch" list="fatherOptions" class="w-full text-xs rounded-full px-3 input-theme" placeholder="ค้นหา ID/ชื่อ..." onchange="validateParent('father')">
                                        <datalist id="fatherOptions"></datalist><input type="hidden" id="p_fatherId">
                                    </div>
                                </div>
                                <div>
                                    <label class="text-xs font-bold text-pink-400 mb-1 block ml-2">พระมารดา</label>
                                    <div class="flex gap-1 relative">
                                        <input type="text" id="p_motherSearch" list="motherOptions" class="w-full text-xs rounded-full px-3 input-theme" placeholder="ค้นหา ID/ชื่อ..." onchange="validateParent('mother')">
                                        <datalist id="motherOptions"></datalist><input type="hidden" id="p_motherId">
                                    </div>
                                </div>
                            </div>
                            <div class="grid grid-cols-12 gap-3">
                                <div class="col-span-12 md:col-span-4">
                                    <label class="text-xs ml-2 text-slate-400">ความสัมพันธ์</label>
                                    <select id="p_relationship" class="w-full text-sm input-theme" onchange="updatePrefixOptions(); checkQueenConsortEligible()"></select>
                                </div>
                                <div class="col-span-6 md:col-span-4">
                                    <label class="text-xs ml-2 text-slate-400">คำนำหน้า</label>
                                    <select id="p_titlePrefix" class="w-full text-sm input-theme" onchange="updateSuffixOptions()"></select>
                                </div>
                                <div class="col-span-6 md:col-span-4">
                                    <label class="text-xs ml-2 text-slate-400">อิสริยยศ</label>
                                    <select id="p_royalRank" class="w-full text-sm input-theme" onchange="updateAutoId(); toggleSurnameFields();">
                                        <option value="เจ้าฟ้า (ชั้นเอก)">เจ้าฟ้า (ชั้นเอก)</option>
                                        <option value="เจ้าฟ้า (ชั้นโท)">เจ้าฟ้า (ชั้นโท)</option>
                                        <option value="เจ้าฟ้า (ชั้นตรี)">เจ้าฟ้า (ชั้นตรี)</option>
                                        <option value="พระองค์เจ้า (ชั้นเอก)">พระองค์เจ้า (ชั้นเอก)</option>
                                        <option value="พระองค์เจ้า (ชั้นโท)">พระองค์เจ้า (ชั้นโท)</option>
                                        <option value="หม่อมเจ้า">หม่อมเจ้า</option>
                                        <option value="หม่อมราชวงศ์">หม่อมราชวงศ์</option>
                                        <option value="หม่อมหลวง">หม่อมหลวง</option>
                                        <option value="เจ้าประเทศราช">เจ้าประเทศราช</option>
                                        <option value="สามัญชน">สามัญชน</option>
                                    </select>
                                </div>
                                <div class="col-span-12">
                                     <label class="flex items-center gap-2 cursor-pointer ml-2">
                                        <input type="checkbox" id="p_hideRoyalRank" class="accent-slate-500 rounded">
                                        <span class="text-xs text-slate-500">ไม่แสดงอิสริยยศ</span>
                                    </label>
                                </div>     
                                <div class="col-span-6 md:col-span-4">
                                    <label class="text-xs font-bold ml-2 text-primary">พระนาม / ชื่อ *</label>
                                    <input type="text" id="p_name" required class="w-full font-bold input-theme">
                                </div>
                                <div class="col-span-6 md:col-span-4">
                                    <label class="text-xs ml-2 text-slate-400">สร้อยพระนาม</label>
                                    <select id="p_titleSuffix" class="w-full text-sm input-theme"></select>
                                </div>
                                <div class="col-span-12 md:col-span-4">
                                    <label class="text-xs ml-2 text-slate-400">ชื่อเล่น</label>
                                    <input type="text" id="p_nickname" class="w-full text-sm input-theme">
                                </div>
                                
                                <!-- START NEW SURNAME INPUTS -->
                                <div class="col-span-12 space-y-3 p-3 rounded-xl border border-slate-100 bg-white shadow-sm">
                                    <div class="flex justify-between items-center">
                                        <label class="flex items-center gap-2 cursor-pointer">
                                            <input type="checkbox" id="p_isSurnameFounder" class="accent-indigo-500 rounded" onchange="toggleSurnameFields()">
                                            <span class="text-sm font-bold text-indigo-600">เป็นต้นราชสกุล?</span>
                                        </label>
                                        <!-- NEW: Hide Surname Toggle -->
                                        <label class="flex items-center gap-2 cursor-pointer text-xs text-slate-500">
                                            <input type="checkbox" id="p_hideSurname" class="accent-slate-500 rounded">
                                            ไม่แสดงนามสกุล
                                        </label>
                                        <!-- END NEW: Hide Surname Toggle -->
                                    </div>
                                    <!-- Field for Royal Surname Founder -->
                                    <div id="royalSurnameFounderPanel" class="hidden">
                                        <label class="text-xs ml-2 text-slate-400">นามสกุลราชสกุล (ตั้งชื่อ)</label>
                                        <input type="text" id="p_royalSurnameInput" class="w-full text-sm input-theme font-bold" placeholder="กรอกชื่อราชสกุล">
                                    </div>
                                    <!-- Field for Commoner Surname -->
                                    <div id="commonerSurnamePanel" class="hidden">
                                        <label class="text-xs ml-2 text-slate-400">นามสกุล (สำหรับสามัญชน)</label>
                                        <input type="text" id="p_commonerSurnameInput" class="w-full text-sm input-theme" placeholder="กรอกนามสกุล (กรอกหรือไม่กรอกก็ได้)">
                                    </div>
                                </div>
                                <!-- END NEW SURNAME INPUTS -->
                                
                                <div class="col-span-6 md:col-span-3">
                                    <label class="text-xs ml-2 text-slate-400">ยศกรม</label>
                                    <select id="p_kromRank" class="w-full text-sm input-theme" onchange="toggleKrom()">
                                        <option value="">-</option><option value="กรมหมื่น">กรมหมื่น</option><option value="กรมขุน">กรมขุน</option><option value="กรมหลวง">กรมหลวง</option><option value="กรมพระ">กรมพระ</option><option value="กรมพระยา">กรมพระยา</option><option value="สมเด็จกรมพระ">สมเด็จกรมพระ</option>
                                    </select>
                                </div>
                                <div class="col-span-6 md:col-span-3">
                                    <label class="text-xs ml-2 text-slate-400">ราชทินนามกรม</label>
                                    <input type="text" id="p_kromTitle" class="w-full text-sm hidden input-theme">
                                </div>
                                
                                <!-- Birth Year Input (Moved to the end of the logical group) -->
                                <div class="col-span-12 md:col-span-6">
                                    <label class="text-xs ml-2 text-slate-400">วันประสูติ (พ.ศ.)</label>
                                    <input type="number" id="p_birthYear" class="w-full text-sm input-theme" placeholder="พ.ศ.">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="p-4 rounded-[20px] border" style="background: var(--bg-dots);">
                            <div class="flex items-center gap-2 mb-2">
                                <input type="checkbox" id="p_hasUmbrella" class="accent-amber-500 w-4 h-4" onchange="toggleUmbrella()">
                                <label class="text-sm font-bold text-amber-700">ได้รับพระราชทานฉัตร</label>
                            </div>
                            <select id="p_umbrellaType" class="w-full text-sm input-theme hidden">
                                <option value="ตรีดลเศวตฉัตร">ตรีดลเศวตฉัตร (3 ชั้น)</option>
                                <option value="เบญจดลเศวตฉัตร">เบญจดลเศวตฉัตร (5 ชั้น)</option>
                                <option value="สัปตดลเศวตฉัตร">สัปตดลเศวตฉัตร (7 ชั้น)</option>
                                <option value="นพดลมหาเศวตฉัตร">นพดลมหาเศวตฉัตร (9 ชั้น)</option>
                            </select>
                        </div>
                        <div class="p-4 rounded-[20px] border" style="background: var(--bg-dots);">
                             <div class="flex justify-between items-center mb-2">
                                <h3 class="text-sm font-bold text-rose-400">คู่สมรส</h3>
                                <div class="flex gap-1">
                                    <input type="text" id="p_spouseSearch" list="spouseOptions" class="text-xs w-28 rounded-full input-theme" placeholder="ค้นหา...">
                                    <datalist id="spouseOptions"></datalist>
                                    <button type="button" onclick="addSpouse()" class="bg-rose-300 text-white w-6 h-6 rounded-full text-xs hover:bg-rose-400">+</button>
                                </div>
                            </div>
                            <ul id="p_spouseList" class="flex flex-wrap gap-2 text-xs"></ul>
                        </div>
                    </div>
                    <div class="flex flex-wrap gap-4 pt-2 items-center">
                        <label class="flex items-center gap-2 cursor-pointer px-4 py-2 rounded-2xl border transition bg-amber-50 border-amber-100">
                            <input type="checkbox" id="p_isMonarch" class="accent-amber-400 w-4 h-4" onchange="toggleMonarch()">
                            <span class="text-sm font-bold text-amber-600">กษัตริย์/ราชินีนาถ</span>
                        </label>
                        <div class="flex items-center gap-2 px-4 py-2 rounded-2xl border transition bg-blue-50 border-blue-100">
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" id="p_isHeir" class="accent-blue-400 w-4 h-4" onchange="toggleHeirOrder()">
                                <span class="text-sm font-bold text-blue-600">รัชทายาท</span>
                            </label>
                            <input type="number" id="p_heirOrder" min="1" placeholder="ลำดับ" class="w-16 text-xs input-theme hidden border-blue-200 text-blue-800 font-bold text-center">
                        </div>
                         <label id="queenConsortOption" class="flex items-center gap-2 cursor-pointer px-4 py-2 rounded-2xl border transition bg-pink-50 border-pink-100 hidden">
                            <input type="checkbox" id="p_isQueenConsort" class="accent-pink-400 w-4 h-4">
                            <span class="text-sm font-bold text-pink-600">พระมเหสีคู่บัลลังก์</span>
                        </label>
                    </div>
                    <div id="monarchPanel" class="hidden bg-gradient-to-r from-amber-50 to-orange-50 p-4 rounded-3xl border border-amber-200 grid grid-cols-4 gap-3 animate-fade-in">
                        <div class="col-span-4 flex flex-col md:flex-row gap-2 mb-2 bg-white/50 p-2 rounded-xl">
                            <div class="flex items-center gap-2 flex-1">
                                <input type="checkbox" id="p_useReignName" class="accent-amber-600" onchange="toggleReignName()">
                                <span class="text-xs font-bold text-amber-800">ใช้นามแผ่นดิน</span>
                                <select id="p_reignNameSelect" class="text-xs input-theme hidden flex-1"></select>
                                <span id="p_autoReignNameNumber" class="text-xs font-bold text-amber-600 hidden bg-amber-100 px-2 py-1 rounded"></span>
                            </div>
                            <div class="flex items-center gap-2 border-l pl-2 border-amber-200">
                                <span class="text-xs font-bold text-amber-800">รัชกาลที่ :</span>
                                <input type="number" id="p_globalReignNumber" class="w-16 text-xs font-bold text-center input-theme border-amber-300 text-amber-900" min="1">
                            </div>
                        </div>
                        <input type="text" id="p_reignStart" placeholder="เริ่มครองราชย์ (พ.ศ.)" class="col-span-1 text-sm bg-white border-amber-100 rounded-lg p-1 text-center">
                        <input type="text" id="p_reignEnd" placeholder="สิ้นสุด (พ.ศ.)" class="col-span-1 text-sm bg-white border-amber-100 rounded-lg p-1 text-center">
                        <input type="text" id="p_eraName" placeholder="ชื่อยุคสมัย" class="col-span-2 text-sm bg-white border-amber-100 rounded-lg p-1">
                        <div id="maleMonarchQueenSelect" class="col-span-4 mt-2 pt-2 border-t border-amber-200/50 hidden">
                            <label class="text-xs font-bold text-amber-700 block mb-1">แต่งตั้งพระมเหสีคู่บัลลังก์ (จากคู่สมรส)</label>
                            <select id="p_queenSelectForKing" class="text-xs input-theme w-full bg-white/80 border-amber-200 text-pink-700 font-bold">
                                <option value="">-- เลือก --</option>
                            </select>
                        </div>
                    </div>
                    <button type="submit" class="hidden"></button>
                </form>
            </div>
            <div class="p-4 flex justify-end gap-3 border-t" style="background: var(--accent-bg);">
                <button onclick="closeModal('personModal')" class="px-5 py-2 rounded-full transition text-sm font-bold bg-gray-100 text-gray-500 hover:bg-gray-200">ยกเลิก</button>
                <button type="submit" form="personForm" class="px-8 py-2 btn-theme text-sm">บันทึกข้อมูล</button>
            </div>
        </div>
    </div>

    
    <!-- Initial Setup Modal -->
    <div id="initialSetupModal" class="modal">
        <div class="modal-content w-full max-w-sm p-8 text-center relative">
            <button onclick="closeModal('initialSetupModal')" class="absolute top-4 right-4 text-gray-300 hover:text-red-400"><i class="fa-solid fa-times"></i></button>
            <h2 class="text-2xl font-cute font-bold mb-2" style="color: var(--text-main);">สร้างอาณาจักร</h2>
            <p class="text-sm mb-6" style="color: var(--text-sub);">เริ่มต้นสร้างราชวงศ์ใหม่ของคุณ</p>
            <div class="space-y-3">
                <input type="text" id="setupKingdomName" class="w-full input-theme text-center" placeholder="ชื่ออาณาจักร">
                <input type="text" id="setupDynastyName" class="w-full input-theme text-center" placeholder="ชื่อราชวงศ์">
            </div>
            <button onclick="completeInitialSetup()" class="btn-theme w-full mt-6 py-3 text-lg">สร้างเลย ✨</button>
        </div>
    </div>

    <!-- Rank & Data Management Modal (Updated HTML with Scores) -->
    <div id="rankManagementModal" class="modal">
    <div class="modal-content rounded-3xl p-0 w-full max-w-6xl h-[85vh] flex flex-col overflow-hidden bg-[#f8fafc]">
        <div class="p-5 bg-white border-b flex justify-between items-center shadow-sm z-10">
            <h2 class="font-cute font-bold text-xl text-slate-800">จัดการข้อมูลและยศ (โปเจียม)</h2>
            <button onclick="closeModal('rankManagementModal')" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-slate-100">✕</button>
        </div>

        <div class="flex flex-1 overflow-hidden p-6 gap-4 flex-col lg:flex-row bg-[#f8fafc]">
            <div class="flex-1 min-w-0 bg-white rounded-[2rem] border border-slate-200 shadow-sm flex flex-col overflow-hidden">
                <div class="p-4 border-b flex items-center gap-2 text-indigo-600 font-bold"><i class="fa-solid fa-layer-group"></i> 1. ความสัมพันธ์</div>
                <div class="p-4 bg-slate-50/50 border-b">
                    <div class="flex gap-2">
                        <input id="nr" class="flex-1 min-w-0 px-3 py-2 rounded-xl border text-sm outline-none focus:ring-2 focus:ring-indigo-400" placeholder="เพิ่มใหม่...">
                        <button onclick="addData('rel')" class="bg-indigo-500 text-white w-10 h-10 rounded-xl hover:bg-indigo-600 transition flex items-center justify-center shrink-0"><i class="fa-solid fa-plus"></i></button>
                    </div>
                </div>
                <ul id="rl" class="flex-1 overflow-y-auto p-2 space-y-1"></ul>
            </div>

            <div class="flex-1 min-w-0 bg-white rounded-[2rem] border border-slate-200 shadow-sm flex flex-col overflow-hidden">
                <div class="p-4 border-b flex items-center gap-2 text-pink-600 font-bold"><i class="fa-solid fa-tag"></i> 2. คำนำหน้า</div>
                <div class="p-4 bg-slate-50/50 border-b">
                    <div class="space-y-2">
                        <div class="flex gap-1">
                            <input id="np" class="flex-grow min-w-0 px-2 py-2 rounded-xl border text-xs outline-none" placeholder="ชื่อ..">
                            <input id="np_score" type="number" class="w-16 shrink-0 px-1 py-2 rounded-xl border text-xs text-center outline-none" placeholder="คะแนน">
                        </div>
                        <button onclick="addData('pre')" class="w-full bg-pink-500 text-white py-2 rounded-xl font-bold text-xs hover:bg-pink-600 transition">+ เพิ่ม</button>
                    </div>
                </div>
                <ul id="pl" class="flex-1 overflow-y-auto p-2 space-y-1"></ul>
            </div>

            <div class="flex-1 min-w-0 bg-white rounded-[2rem] border border-slate-200 shadow-sm flex flex-col overflow-hidden">
                <div class="p-4 border-b flex items-center gap-2 text-emerald-600 font-bold"><i class="fa-solid fa-medal"></i> 3. สร้อยพระนาม</div>
                <div class="p-4 bg-slate-50/50 border-b">
                    <div class="space-y-2">
                        <div class="flex gap-1">
                            <input id="ns" class="flex-grow min-w-0 px-2 py-2 rounded-xl border text-xs outline-none" placeholder="สร้อย..">
                            <input id="ns_score" type="number" class="w-16 shrink-0 px-1 py-2 rounded-xl border text-xs text-center outline-none" value="0">
                        </div>
                        <button onclick="addData('suf')" class="w-full bg-emerald-500 text-white py-2 rounded-xl font-bold text-xs hover:bg-emerald-600 transition">+ เพิ่ม</button>
                    </div>
                </div>
                <ul id="sl" class="flex-1 overflow-y-auto p-2 space-y-1"></ul>
            </div>

            <div class="flex-1 min-w-0 bg-amber-50/30 rounded-[2rem] border border-amber-200 shadow-sm flex flex-col overflow-hidden">
                <div class="p-4 border-b flex items-center gap-2 text-amber-600 font-bold"><i class="fa-solid fa-crown"></i> 4. นามแผ่นดิน</div>
                <div class="p-4 bg-white/50 border-b">
                    <div class="flex gap-2">
                        <input id="nreign" class="flex-1 min-w-0 px-3 py-2 rounded-xl border border-amber-100 outline-none text-sm" placeholder="ชื่อแผ่นดิน...">
                        <button onclick="addData('reign')" class="bg-amber-500 text-white w-10 h-10 rounded-xl hover:bg-amber-600 flex items-center justify-center shrink-0"><i class="fa-solid fa-plus"></i></button>
                    </div>
                </div>
                <ul id="reignl" class="flex-1 overflow-y-auto p-2 space-y-1"></ul>
            </div>
        </div>
    </div>
</div>

    <!-- Appoint Modal -->
    <div id="appointModal" class="modal">
        <div class="modal-content w-full max-w-sm p-6 text-center">
            <h3 class="font-bold text-lg mb-4 text-red-600">สถาปนาพระมหากษัตริย์</h3>
            <p class="text-xs text-slate-500 mb-4">เลือกผู้สืบราชสมบัติ (ยกเว้น: บาทบริจาริกา, สามัญชน, หม่อมเจ้า)</p>
            <select id="appointSelectModal" class="input-theme w-full mb-4"></select>
            <button onclick="appointFromModal()" class="btn-theme w-full">ยืนยันการสถาปนา</button>
            <button onclick="closeModal('appointModal')" class="mt-2 text-xs text-slate-400">ยกเลิก</button>
        </div>
    </div>

    <!-- Reign Name Selection Modal -->
    <div id="reignSelectionModal" class="modal">
        <div class="modal-content w-full max-w-sm p-6 text-center">
            <h3 class="font-bold text-lg mb-4 text-amber-600">เลือกพระนามแผ่นดิน</h3>
            <p class="text-xs text-slate-500 mb-4">โปรดเลือกพระนามสำหรับรัชกาลใหม่</p>
            <select id="reignSelectionInput" class="input-theme w-full mb-4"></select>
            <button onclick="confirmReignSelection()" class="btn-theme w-full">ยืนยัน</button>
        </div>
    </div>
    
    <!-- Relationship Finder Modal -->
    <div id="relationshipModal" class="modal">
        <div class="modal-content w-full max-w-md p-6 relative">
            <button onclick="closeModal('relationshipModal')" class="absolute top-4 right-4 text-slate-300 hover:text-red-400"><i class="fa-solid fa-times"></i></button>
            <h3 class="font-cute font-bold text-xl mb-6 text-center text-primary"><i class="fa-solid fa-users-rays mr-2"></i>ค้นหาความสัมพันธ์</h3>
            
            <div class="space-y-4">
                <div class="bg-indigo-50 p-4 rounded-2xl border border-indigo-100">
                    <label class="text-xs font-bold text-indigo-500 mb-1 block">บุคคลที่ 1 (A)</label>
                    <div class="flex gap-2">
                        <div class="w-10 h-10 rounded-full bg-white border-2 border-indigo-200 flex items-center justify-center overflow-hidden">
                            <img id="rel_img_a" src="" class="w-full h-full object-cover opacity-50">
                        </div>
                        <input type="text" id="rel_input_a" list="relOptions" class="flex-1 input-theme text-sm" placeholder="พิมพ์ชื่อ..." onchange="updateRelPreview('a')">
                    </div>
                    <input type="hidden" id="rel_id_a">
                </div>
                
                <div class="flex justify-center -my-2 relative z-10">
                    <div class="bg-white p-2 rounded-full shadow-sm border text-slate-400 text-xs">
                        <i class="fa-solid fa-arrow-down-up"></i>
                    </div>
                </div>

                <div class="bg-pink-50 p-4 rounded-2xl border border-pink-100">
                    <label class="text-xs font-bold text-pink-500 mb-1 block">บุคคลที่ 2 (B)</label>
                    <div class="flex gap-2">
                         <div class="w-10 h-10 rounded-full bg-white border-2 border-pink-200 flex items-center justify-center overflow-hidden">
                            <img id="rel_img_b" src="" class="w-full h-full object-cover opacity-50">
                        </div>
                        <input type="text" id="rel_input_b" list="relOptions" class="flex-1 input-theme text-sm" placeholder="พิมพ์ชื่อ..." onchange="updateRelPreview('b')">
                    </div>
                    <input type="hidden" id="rel_id_b">
                </div>
                
                <datalist id="relOptions"></datalist>
                
                <button onclick="calculateRelationship()" class="btn-theme w-full py-3 mt-2 shadow-lg shadow-indigo-200">
                    <i class="fa-solid fa-search mr-2"></i> ค้นหาและแสดงเส้นทาง
                </button>
            </div>
        </div>
    </div>

    <!-- Fantasy Celebration Modal -->
    <div id="fantasyModal" class="modal">
        <div class="modal-content">
            <button onclick="closeModal('fantasyModal')" class="absolute top-2 right-2 text-amber-200 hover:text-white z-20">✕</button>
            <div id="fantasyParticles"></div>
            
            <div class="golden-frame">
                <img id="fan_img" src="" class="w-32 h-32 rounded-full object-cover border-4 border-black">
            </div>
            
            <div class="space-y-4 relative z-10">
                <div class="font-royal text-sm text-amber-200 tracking-widest uppercase">ขอถวายพระพร</div>
                <h2 id="fan_name" class="font-royal text-2xl md:text-3xl shimmer-text leading-tight px-4"></h2>
                
                <div class="text-xs text-amber-100/80 font-light mt-4">
                    ราชวงศ์ <span id="fan_dynasty" class="font-bold text-white"></span> แห่งอาณาจักร <span id="fan_kingdom" class="font-bold text-white"></span><br>
                    ทรงได้รับการราชาภิเษกเสวยถวัลยราชสมบัติ<br>
                    เป็น <span id="fan_rama" class="font-bold text-lg text-white"></span>
                </div>

                <div class="my-6 h-px w-3/4 mx-auto bg-gradient-to-r from-transparent via-[#d4af37] to-transparent"></div>

                <p class="text-xs md:text-sm text-amber-100 italic leading-relaxed px-4">
                    "ด้วยพระปรีชาสามารถและพระบรมเดชานุภาพ<br>
                    ขอให้ใต้ฝ่าละอองธุลีพระบาททรงนำพาอาณาประชาราษฎร์สู่ความร่มเย็นผาสุก<br>
                    บ้านเมืองไพบูลย์ เจริญรุ่งเรืองตลอดกาลนาน"
                </p>

                <div class="font-royal text-xl text-[#ffd700] mt-6 animate-pulse">
                    ขอองค์พระมหากษัตริย์รัชกาลใหม่ทรงพระเจริญ
                </div>
            </div>
        </div>
    </div>
    
    <!-- Spouse Selection Method Modal (NEW) -->
    <div id="spouseSelectionModal" class="modal">
        <div class="modal-content w-full max-w-sm p-6 relative overflow-hidden">
            <button onclick="closeModal('spouseSelectionModal')" class="absolute top-3 right-3 text-slate-300 hover:text-red-400"><i class="fa-solid fa-times"></i></button>
            
            <div class="text-center mb-6">
                <div class="w-16 h-16 bg-pink-100 rounded-full flex items-center justify-center mx-auto mb-3 text-pink-500 text-2xl border-2 border-pink-200">
                    <i class="fa-solid fa-heart"></i>
                </div>
                <h3 class="font-cute font-bold text-xl text-slate-700">เพิ่มคู่สมรส</h3>
                <p class="text-xs text-slate-500 mt-1">กรุณาเลือกวิธีการเพิ่มข้อมูล</p>
            </div>

            <div class="space-y-4">
                <!-- Option 1: Existing Person -->
                <div class="bg-slate-50 p-4 rounded-2xl border border-slate-200">
                    <label class="text-xs font-bold text-slate-500 mb-2 block"><i class="fa-solid fa-users mr-1"></i> เลือกจากรายชื่อที่มีอยู่แล้ว</label>
                    <div class="flex gap-2">
                        <div class="relative flex-1">
                            <!-- Note: list attribute is bound to eligibleSpouseList -->
                            <input type="text" id="existingSpouseSearch" list="eligibleSpouseList" class="w-full input-theme text-sm pl-8" placeholder="ค้นหา ID หรือชื่อ..." onchange="validateExistingSpouseInput()">
                            <i class="fa-solid fa-search absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 text-xs"></i>
                        </div>
                        <input type="hidden" id="selectedExistingSpouseId">
                    </div>
                    <datalist id="eligibleSpouseList"></datalist>
                    <button onclick="confirmLinkExistingSpouse()" class="w-full mt-2 py-2 bg-white border border-pink-200 text-pink-600 font-bold rounded-xl text-xs hover:bg-pink-50 transition shadow-sm">
                        เชื่อมโยงเป็นคู่สมรส
                    </button>
                </div>

                <div class="relative flex py-1 items-center">
                    <div class="flex-grow border-t border-slate-200"></div>
                    <span class="flex-shrink-0 mx-4 text-slate-300 text-[10px]">หรือ</span>
                    <div class="flex-grow border-t border-slate-200"></div>
                </div>

                <!-- Option 2: New Person -->
                <button onclick="proceedToNewSpouse()" class="w-full py-3 btn-theme flex items-center justify-center gap-2 shadow-lg shadow-pink-100">
                    <i class="fa-solid fa-plus-circle"></i> สร้างตัวละครใหม่
                </button>
            </div>
        </div>
    </div>
    <!-- End Spouse Selection Method Modal -->

    <div id="historyModal" class="modal">
    <div class="modal-content w-full max-w-md p-6 relative">
        <button onclick="closeModal('historyModal')" class="absolute top-4 right-4 text-slate-300 hover:text-red-400"><i class="fa-solid fa-times"></i></button>
        <h3 class="font-cute font-bold text-xl mb-4 text-center text-slate-700">
            <i class="fa-solid fa-history mr-2"></i>ทำเนียบพระยศ
        </h3>
        <div id="historyList" class="space-y-4 max-h-[60vh] overflow-y-auto pr-2 custom-scrollbar">
            </div>
    </div>
</div>
    <!-- Toast Container -->
    <div id="toast-container"></div>

<script>
// ================= CONFIG & CONSTANTS =================
const DEFAULT_IMG_MALE = "https://cdn-icons-png.flaticon.com/512/4128/4128176.png";
const DEFAULT_IMG_FEMALE = "https://cdn-icons-png.flaticon.com/512/4128/4128253.png";

const BASE_CONFIG = { nodeWidth: 180, nodeHeight: 100, gapX: 40, gapY: 150, spouseGap: 50 };
const ANCESTOR_CONFIG = { nodeWidth: 160, nodeHeight: 90, gapX: 50, gapY: 120 };
// Added new ranks for MR/ML
const RANK_CODES = { "เจ้าฟ้า (ชั้นเอก)":'1', "เจ้าฟ้า (ชั้นโท)":'2', "เจ้าฟ้า (ชั้นตรี)":'3', "พระองค์เจ้า (ชั้นเอก)":'4', "พระองค์เจ้า (ชั้นโท)":'5', "หม่อมเจ้า":'6', "หม่อมราชวงศ์":'7', "หม่อมหลวง":'8', "เจ้าประเทศราช":'9', "สามัญชน":'A' };

// ================= GLOBAL STATE =================
let appIndex = []; // List of all kingdoms [{id, kingdomName, dynastyName}]
let currentKingdomId = null;

let state = {
    kingdomName: "อาณาจักร",
    dynastyName: "ราชวงศ์",
    members: [],
    reignNames: ["พระรามาธิบดี", "พระปรเมนทร", "พระปรมินทร", "พระมหาธรรมราชา", "พระร่วงเจ้า", "พระบรมราชา", "พระมหาจักรพรรดิ"], 
    hierarchy: {
        "พระมหากษัตริย์": { prefixes: ["สมเด็จพระ"], suffixes: { "สมเด็จพระ": ["เจ้าอยู่หัว"] } },
        "พระราชินีนาถ": { prefixes: ["สมเด็จพระนางเจ้า"], suffixes: { "สมเด็จพระนางเจ้า": ["พระบรมราชินีนาถ"] } },
        "พระภรรยาเจ้า": { prefixes: ["สมเด็จพระนางเจ้า", "พระราชชายา"], suffixes: { "สมเด็จพระนางเจ้า": ["พระบรมราชินี", "พระบรมราชเทวี"], "พระราชชายา": [""] } }, // Added Phra Ratchachaya suffix option
        "บาทบริจาริกา": { prefixes: ["เจ้าจอม", "เจ้าคุณจอม", "เจ้าจอมมารดา", "เจ้าคุณจอมมารดา"], suffixes: {} }, // Consort of Monarch
        
        // Non-Monarch Consorts (NEW)
        "พระชายา": { prefixes: ["พระชายา", "หม่อมเจ้า"], suffixes: {} }, // Royal Consort of a Prince
        "หม่อม": { prefixes: ["หม่อม", "คุณ"], suffixes: {} }, // Commoner Consort of a Prince
        
        "พระราชโอรส": { prefixes: ["สมเด็จพระเจ้าลูกยาเธอ", "พระเจ้าลูกยาเธอ"], suffixes: { "สมเด็จพระเจ้าลูกยาเธอ": ["บรมราชกุมาร"], "พระเจ้าลูกยาเธอ": ["บวรราชกุมาร"] } },
        "พระราชธิดา": { prefixes: ["สมเด็จพระเจ้าลูกเธอ", "พระเจ้าลูกเธอ"], suffixes: { "สมเด็จพระเจ้าลูกเธอ": ["บรมราชกุมารี", "เจ้านายฝ่ายใน"], "พระเจ้าลูกเธอ": ["เจ้านายฝ่ายใน"] } },
        
        // NEW SUCCESSION RANKS
        "พระเจ้าพี่น้องร่วมพระมารดา": { prefixes: ["สมเด็จพระเจ้าพี่ยาเธอ", "สมเด็จพระเจ้าน้องยาเธอ", "พระเจ้าพี่ยาเธอ", "พระเจ้าน้องยาเธอ", "สมเด็จพระเจ้าพี่นางเธอ", "สมเด็จพระเจ้าน้องนางเธอ", "พระเจ้าพี่นางเธอ", "พระเจ้าน้องนางเธอ"], suffixes: {} },
        "พระบรมวงศ์": { prefixes: ["สมเด็จพระเจ้าบรมวงศ์เธอ", "พระเจ้าบรมวงศ์เธอ"], suffixes: {} },
        "พระอนุวงศ์": { prefixes: ["สมเด็จพระเจ้าวรวงศ์เธอ", "พระเจ้าวรวงศ์เธอ"], suffixes: {} },
        
        "พระเจ้าหลานเธอ": { prefixes: ["สมเด็จพระเจ้าหลานเธอ", "พระเจ้าหลานเธอ"], suffixes: {} }, // สำหรับหลานสายตรงของพระมหากษัตริย์
        "รัชทายาท": { prefixes: ["สมเด็จพระบรมโอรสาธิราช"], suffixes: { "สมเด็จพระบรมโอรสาธิราช": ["สยามมกุฎราชกุมาร"] } },
        // UPDATED: Prefixes for commoners
        "สามัญชน": { prefixes: ["นาย", "นาง", "นางสาว", "คุณ", "คุณหญิง", "ท่านผู้หญิง"], suffixes: {} }
    },
    prefixScores: {}, // New: เก็บตะแนนคำนำหน้า
    suffixScores: {}, // New: เก็บคะแนนสร้อย
    currentTheme: 'white',
    zoom: 1, panX: window.innerWidth/2, panY: 50, isDragging: false, isHorizontal: false,
    viewRootId: null, 
    viewMode: 'tree',
    treeViewType: 'all', // all, descendants, direct, ancestors, royalSurname (NEW)
    currentSurnameRootId: null, // NEW
    currentReignFilter: 'all', // NEW: Added for filtering surname founders
    highlightIds: [] // IDs to flash
};

// ================= INITIALIZATION & KINGDOM MANAGEMENT =================
let targetOriginIdForSpouse = null; // NEW: Global state to hold the person ID requesting a spouse

window.onload = () => {
    loadAppIndex();
    
    // Check if we have any kingdoms
    if(appIndex.length === 0) {
        // Try to migrate from old single-save version
        const oldSave = localStorage.getItem('royal_tree_v2');
        if(oldSave) {
            const oldData = JSON.parse(oldSave);
            createNewKingdom(oldData.kingdomName || "อาณาจักรเดิม", oldData.dynastyName || "ราชวงศ์เดิม", oldData);
            localStorage.removeItem('royal_tree_v2'); // Clean up old save
        } else {
            document.getElementById('initialSetupModal').classList.add('active');
        }
    } else {
        // Load the last used kingdom or the first one
        const lastId = localStorage.getItem('royal_tree_last_id');
        if(lastId && appIndex.find(k => k.id === lastId)) {
            switchKingdom(lastId);
        } else {
            switchKingdom(appIndex[0].id);
        }
    }
    
    setupPanZoom();
};

function loadAppIndex() {
    const raw = localStorage.getItem('royal_tree_index');
    appIndex = raw ? JSON.parse(raw) : [];
    renderKingdomSelector();
}

function saveAppIndex() {
    localStorage.setItem('royal_tree_index', JSON.stringify(appIndex));
    renderKingdomSelector();
}

function renderKingdomSelector() {
    const sel = document.getElementById('kingdomSelector');
    sel.innerHTML = '';
    appIndex.forEach(k => {
        const op = document.createElement('option');
        op.value = k.id;
        op.innerText = k.kingdomName + " (" + k.dynastyName + ")";
        if(k.id === currentKingdomId) op.selected = true;
        sel.appendChild(op);
    });
}

function createNewKingdom(kName, dName, initialData = null) {
    const newId = 'kingdom_' + Date.now();
    const meta = { id: newId, kingdomName: kName, dynastyName: dName };
    appIndex.push(meta);
    saveAppIndex();

    // Init state for new kingdom
    let newState = JSON.parse(JSON.stringify(state)); // Clone default
    if(initialData) newState = {...newState, ...initialData};
    newState.kingdomName = kName;
    newState.dynastyName = dName;
    newState.members = initialData ? initialData.members : [];
    
    // Save new kingdom data
    localStorage.setItem('royal_tree_data_' + newId, JSON.stringify(newState));
    
    switchKingdom(newId);
}

function switchKingdom(id) {
    currentKingdomId = id;
    localStorage.setItem('royal_tree_last_id', id);
    
    const dataRaw = localStorage.getItem('royal_tree_data_' + id);
    if(dataRaw) {
        state = JSON.parse(dataRaw);
    } else {
        // Fallback should not happen normally
        state.members = [];
    }

    // Init scores if missing from old save
    if(!state.prefixScores) state.prefixScores = {};
    if(!state.suffixScores) state.suffixScores = {};
    
    // Init new surname state if missing
    if(!state.currentSurnameRootId) state.currentSurnameRootId = null;
    if(!state.currentReignFilter) state.currentReignFilter = 'all';

    // Update UI
    document.getElementById('kingdomSelector').value = id;
    document.getElementById('dynastyLabel').innerText = state.dynastyName;
    setTheme(state.currentTheme || 'white');
    
    // Restore View Settings
    document.getElementById('treeViewMode').value = state.treeViewType || 'all';
    
    updateApp();
}

function deleteCurrentKingdom() {
    if(appIndex.length <= 1) {
        showToast("ไม่สามารถลบอาณาจักรสุดท้ายได้");
        return;
    }
    if(!confirm(`ยืนยันการลบอาณาจักร "${state.kingdomName}" ? ข้อมูลจะหายไปถาวร`)) return;

    localStorage.removeItem('royal_tree_data_' + currentKingdomId);
    appIndex = appIndex.filter(k => k.id !== currentKingdomId);
    saveAppIndex();
    
    switchKingdom(appIndex[0].id);
    showToast("ลบอาณาจักรเรียบร้อย");
}

function completeInitialSetup() { 
    const kName = document.getElementById('setupKingdomName').value || "อาณาจักร"; 
    const dName = document.getElementById('setupDynastyName').value || "ราชวงศ์"; 
    createNewKingdom(kName, dName);
    closeModal('initialSetupModal'); 
}

function openCreateKingdomModal() {
    document.getElementById('setupKingdomName').value = "";
    document.getElementById('setupDynastyName').value = "";
    document.getElementById('initialSetupModal').classList.add('active');
}

function saveState() { 
    if(!currentKingdomId) return;
    localStorage.setItem('royal_tree_data_' + currentKingdomId, JSON.stringify(state)); 
    
    // Update index name if changed
    const idx = appIndex.findIndex(k => k.id === currentKingdomId);
    if(idx !== -1) {
        if(appIndex[idx].kingdomName !== state.kingdomName || appIndex[idx].dynastyName !== state.dynastyName) {
            appIndex[idx].kingdomName = state.kingdomName;
            appIndex[idx].dynastyName = state.dynastyName;
            saveAppIndex();
        }
    }
}

function updateApp() {
    if(state.viewMode === 'tree') renderTree();
    else renderTable();
    renderMonarchBanner();
    populateSearchLists();
}

// ================= VIEW LOGIC =================

function switchView(mode) {
    state.viewMode = mode;
    saveState();
    const treeBtn = document.getElementById('btn-view-tree');
    const tableBtn = document.getElementById('btn-view-table');
    const canvas = document.getElementById('canvas-container');
    const table = document.getElementById('tableView');

    if(mode === 'tree') {
        canvas.classList.remove('hidden'); table.classList.add('hidden');
        treeBtn.style.background = "var(--primary)"; treeBtn.style.color = "white";
        tableBtn.style.background = "transparent"; tableBtn.style.color = "#64748b";
        renderTree();
    } else {
        canvas.classList.add('hidden'); table.classList.remove('hidden');
        tableBtn.style.background = "var(--primary)"; tableBtn.style.color = "white";
        treeBtn.style.background = "transparent"; treeBtn.style.color = "#64748b";
        renderTable();
    }
}

function changeRoyalSurnameRoot(founderId) {
    state.currentSurnameRootId = founderId;
    saveState();
    renderTree();
    resetView();
}

function changeRoyalSurnameFilter(reignId = null) {
    const selectedReignId = reignId || document.getElementById('reignFilterSelector').value;
    state.currentReignFilter = selectedReignId;
    
    let founders = getRoyalSurnameFounders(); // Get all founders

    // Filter founders based on selected Reign (Monarch's descendant)
    if (selectedReignId !== 'all') {
        const descendantIds = getMonarchDescendants(selectedReignId);
        // A founder is included if they are a descendant of the selected monarch OR if they *are* the monarch.
        // NOTE: A Monarch can also be a founder of a Royal Surname.
        founders = founders.filter(f => descendantIds.has(f.id) || f.id === selectedReignId);
    }

    // Update the Royal Surname Selector dropdown with the filtered list
    populateRoyalSurnameSelector(founders); 

    // Reset current root if the previous one is filtered out
    if (state.currentSurnameRootId && !founders.some(f => f.id === state.currentSurnameRootId)) {
        state.currentSurnameRootId = founders.length > 0 ? founders[0].id : null;
    } else if (!state.currentSurnameRootId && founders.length > 0) {
        state.currentSurnameRootId = founders[0].id;
    }
    
    saveState();
    renderTree(); // Re-render with the new root/filters
    updateSurnameHeader();
}

function changeViewMode(mode) {
    state.treeViewType = mode;
    const surnameSelector = document.getElementById('royalSurnameSelector');
    const surnameHeader = document.getElementById('surnameViewHeader');
    const reignFilterSelector = document.getElementById('reignFilterSelector');

    if (mode === 'royalSurname') {
        populateReignFilterSelector();
        reignFilterSelector.classList.remove('hidden');
        
        // This will now call changeRoyalSurnameFilter, which populates the surname selector
        changeRoyalSurnameFilter(state.currentReignFilter); 

        surnameSelector.classList.remove('hidden');
        surnameHeader.classList.remove('hidden');
        updateSurnameHeader();
    } else {
        surnameSelector.classList.add('hidden');
        surnameHeader.classList.add('hidden');
        reignFilterSelector.classList.add('hidden');
    }

    saveState();
    renderTree();
    resetView();
    showToast(`เปลี่ยนมุมมองเป็น: ${document.querySelector('#treeViewMode option[value="'+mode+'"]').text}`);
}

function findAbsoluteRoot(startId) {
    if(!startId) return null;
    let curr = state.members.find(m => m.id === startId);
    if(!curr) return null;
    let guard = 0;
    while((curr.fatherId || curr.motherId) && guard < 50) {
        let parent = null;
        if(curr.fatherId) parent = state.members.find(m => m.id === curr.fatherId);
        if(!parent && curr.motherId) parent = state.members.find(m => m.id === curr.motherId);
        
        if(parent) curr = parent;
        else break;
        guard++;
    }
    return curr.id;
}

function getDirectLineMembers(focusId) {
    const directIds = new Set();
    const spousesToAdd = new Set();
    
    let curr = state.members.find(m => m.id === focusId);
    while(curr) {
        directIds.add(curr.id);
        if(curr.spouseIds) curr.spouseIds.forEach(s => spousesToAdd.add(s));
        if(curr.fatherId) curr = state.members.find(m => m.id === curr.fatherId);
        else if(curr.motherId) curr = state.members.find(m => m.id === curr.motherId);
        else curr = null;
    }

    function addDescendants(pid) {
        const children = state.members.filter(m => m.fatherId === pid || m.motherId === pid);
        children.forEach(c => {
            directIds.add(c.id);
            if(c.spouseIds) c.spouseIds.forEach(s => spousesToAdd.add(s));
            addDescendants(c.id);
        });
    }
    addDescendants(focusId);

    spousesToAdd.forEach(s => directIds.add(s));
    return state.members.filter(m => directIds.has(m.id));
}

function getRoyalSurnameFounders() {
    // Note: Use isRoyalSurnameFounder flag to correctly identify the designated founder, 
    // even if other people have the same surname property (due to inheritance).
    return state.members.filter(m => m.isRoyalSurnameFounder && m.royalSurname && m.royalSurname.trim() !== '')
                        .sort((a, b) => a.royalSurname.localeCompare(b.royalSurname, 'th'));
}

// NEW HELPER: Find the founder ID of the royal surname a person belongs to.
function getSurnameFounderForPerson(id) {
    const p = state.members.find(m => m.id === id);
    if (!p || !p.royalSurname) return null;

    // Find the member who is designated as the founder and has the same royalSurname
    const founder = state.members.find(m => m.isRoyalSurnameFounder && m.royalSurname === p.royalSurname);
    
    // Fallback: If no designated founder found, but the person themselves is the founder, use them.
    if (p.isRoyalSurnameFounder && p.royalSurname && !founder) return p.id;
    
    return founder ? founder.id : null;
}
// END NEW HELPER

function getMonarchsByReign() {
    return state.members.filter(m => m.isMonarch && m.globalReignNumber)
                        .sort((a, b) => parseInt(a.globalReignNumber) - parseInt(b.globalReignNumber));
}

function getMonarchDescendants(monarchId) {
    const descendantIds = new Set();
    function traverse(id) {
        if (descendantIds.has(id)) return;
        descendantIds.add(id);
        state.members.filter(m => m.fatherId === id || m.motherId === id)
                     .forEach(c => traverse(c.id));
    }
    traverse(monarchId);
    return descendantIds;
}

function populateReignFilterSelector() {
    const sel = document.getElementById('reignFilterSelector');
    sel.innerHTML = '<option value="all">กรองตามเชื้อสายรัชกาล... (ทั้งหมด)</option>';
    
    const monarchs = getMonarchsByReign();
    monarchs.forEach(m => {
        const rNum = toThaiNumerals(m.globalReignNumber);
        const op = document.createElement('option');
        op.value = m.id; // Filter by the Monarch's ID
        op.innerText = `เชื้อสายรัชกาลที่ ${rNum} (${m.name})`;
        if (m.id === state.currentReignFilter) op.selected = true;
        sel.appendChild(op);
    });
}

function populateRoyalSurnameSelector(founders) {
    const sel = document.getElementById('royalSurnameSelector');
    sel.innerHTML = '';
    
    if (founders.length === 0) {
        sel.innerHTML = '<option value="">(ไม่พบราชสกุลในตัวกรอง)</option>';
        return;
    }

    founders.forEach(f => {
        const op = document.createElement('option');
        op.value = f.id;
        op.innerText = `ราชสกุล.${f.royalSurname} (${f.name})`;
        if (f.id === state.currentSurnameRootId) op.selected = true;
        sel.appendChild(op);
    });
}

function updateSurnameHeader() {
    const founder = state.members.find(m => m.id === state.currentSurnameRootId);
    if (founder) {
        document.getElementById('surnameHeaderName').innerText = `ราชสกุล.${founder.royalSurname}`;
    } else {
         document.getElementById('surnameHeaderName').innerText = `ราชสกุล. (ไม่พบ)`;
    }
}

function getRoyalSurnameMembers(founderId) {
    const founder = state.members.find(m => m.id === founderId);
    if (!founder || !founder.royalSurname) return [];

    const lineageIds = new Set();
    const currentSurname = founder.royalSurname;
    
    // 1. Traverse descendants (including spouses)
    function addDescendants(id, currentSurnameRoot) {
        const p = state.members.find(m => m.id === id);
        if (!p) return;

        // Stop traversal if a descendant establishes a new surname (and it's not the current root)
        if (p.id !== founderId && p.isRoyalSurnameFounder && p.royalSurname && p.royalSurname !== currentSurnameRoot) {
             return;
        }
        
        if (lineageIds.has(id)) return;
        lineageIds.add(id);

        // Add spouses
        (p.spouseIds || []).forEach(sid => lineageIds.add(sid));

        // Recurse children
        state.members.filter(c => c.fatherId === id || c.motherId === id)
                     .forEach(c => addDescendants(c.id, currentSurnameRoot));
    }

    // 2. Traverse ancestors (and spouses) up to the founder
    function addAncestorsToFounder(id) {
        const p = state.members.find(m => m.id === id);
        if (!p || lineageIds.has(id)) return;
        
        lineageIds.add(id);
        // Add spouses
        (p.spouseIds || []).forEach(sid => lineageIds.add(sid));

        if (p.id === founderId) return; // Stop at the founder

        // Only trace direct, bloodline ancestors
        if (p.fatherId) addAncestorsToFounder(p.fatherId);
        if (p.motherId) addAncestorsToFounder(p.motherId);
    }

    // Start traversal from founder
    addDescendants(founderId, currentSurname);
    // Add ancestors up to the original founder (this implicitly includes the founder itself)
    addAncestorsToFounder(founderId);

    return state.members.filter(m => lineageIds.has(m.id));
}

function renderTree() {
    const focusId = state.viewRootId || (state.members.find(x => x.isMonarch && x.isAlive && !x.isExMonarch)?.id) || (state.members[0]?.id);
    
    // Toggle surname controls visibility (for persistence on reload)
    const surnameSelector = document.getElementById('royalSurnameSelector');
    const surnameHeader = document.getElementById('surnameViewHeader');
    const reignFilterSelector = document.getElementById('reignFilterSelector');
    const isSurnameView = state.treeViewType === 'royalSurname';
    
    surnameSelector.classList.toggle('hidden', !isSurnameView);
    surnameHeader.classList.toggle('hidden', !isSurnameView);
    reignFilterSelector.classList.toggle('hidden', !isSurnameView);

    if(!focusId) { document.getElementById('empty-state').classList.remove('hidden'); return; }
    document.getElementById('empty-state').classList.add('hidden');

    const svgL = document.getElementById('links-layer');
    const svgN = document.getElementById('nodes-layer');
    svgL.innerHTML = ''; svgN.innerHTML = '';

    let renderRootId = focusId;
    let membersToRender = state.members;

    if (state.treeViewType === 'all') {
        renderRootId = findAbsoluteRoot(focusId);
        membersToRender = state.members;
    } else if (state.treeViewType === 'descendants') {
        renderRootId = focusId;
        membersToRender = state.members;
    } else if (state.treeViewType === 'direct') {
        renderRootId = findAbsoluteRoot(focusId);
        membersToRender = getDirectLineMembers(focusId);
    } else if (state.treeViewType === 'ancestors') {
        const layout = calculateAncestryLayout(focusId);
        // FIX: Use c.fromUUID and c.toUUID to find nodes based on layoutId
        layout.connections.forEach(c => {
            const f = layout.nodes.find(n => n.layoutId === c.fromUUID);
            const t = layout.nodes.find(n => n.layoutId === c.toUUID);
            // In Ancestor View, isSpouse is always false
            if(f && t) drawLink(f, t, false, svgL); 
        });
        layout.nodes.forEach(n => drawNode(n, svgN));
        return;
    } else if (isSurnameView) {
        // Handle Royal Surname View
        
        // This is necessary to ensure the selectors are correctly populated on direct load/rerender
        // if changeViewMode wasn't called (e.g., after focus change).
        if (!document.getElementById('reignFilterSelector').options.length > 1) {
             populateReignFilterSelector();
        }
        
        if (reignFilterSelector.value !== state.currentReignFilter || surnameSelector.options.length === 0) {
             changeRoyalSurnameFilter(state.currentReignFilter);
        }

        if (!state.currentSurnameRootId) {
             surnameHeader.classList.add('hidden');
             document.getElementById('empty-state').classList.remove('hidden');
             return;
        }
        updateSurnameHeader();
        
        membersToRender = getRoyalSurnameMembers(state.currentSurnameRootId);
        if (membersToRender.length === 0) {
            const founder = state.members.find(m => m.id === state.currentSurnameRootId);
            if (founder) membersToRender.push(founder);
        }
        
        if (membersToRender.length === 0) {
             document.getElementById('empty-state').classList.remove('hidden');
             return;
        }

        // Use the founder ID as the root for layout calculation
        renderRootId = state.currentSurnameRootId; 
    }


    const layout = calculateTreeLayout(renderRootId, membersToRender);
    
    layout.connections.forEach(c => {
        // [แก้ไข] ค้นหา Node จาก layoutId (UUID) แทน ID ข้อมูลจริง
        const f = layout.nodes.find(n => n.layoutId === c.fromUUID);
        const t = layout.nodes.find(n => n.layoutId === c.toUUID);
        if(f && t) drawLink(f, t, c.isSpouse, svgL);
    });
    layout.nodes.forEach(n => drawNode(n, svgN));
}

    function calculateAncestryLayout(rootId) {
        const nodes = [];
        const connections = [];
        const maxGen = 4; // Self(0), Parents(1), Grand(2), Great(3), GreatGreat(4)
        
        function getRelName(path) {
            if(path === "") return "ตนเอง";
            const p = path.toLowerCase();
            if(p === "f") return "พ่อ";
            if(p === "m") return "แม่";
            if(p === "ff") return "ปู่";
            if(p === "fm") return "ย่า";
            if(p === "mf") return "ตา";
            if(p === "mm") return "ยาย";
            if(p.length === 3) return "ทวด";
            if(p.length === 4) return "เทียด";
            return "";
        }

        function addAncestor(id, gen, path, yOffset, range) {
            if (gen > maxGen) return;
            const p = state.members.find(m => m.id === id);
            if (!p) return;
            
            // [เพิ่ม layoutId ใน ancestor view ด้วย]
            const ancestorLayoutId = `ancestor_${id}_${gen}_${path}`;

            let x, y;
            if(state.isHorizontal) {
                // Horizontal: Root Left -> Ancestors Right
                x = gen * (ANCESTOR_CONFIG.nodeWidth + ANCESTOR_CONFIG.gapX);
                y = yOffset;
            } else {
                // Vertical: Root Bottom -> Ancestors Top
                x = yOffset;
                y = -(gen * (ANCESTOR_CONFIG.nodeHeight + ANCESTOR_CONFIG.gapY));
            }

            nodes.push({ data: p, x, y, type: 'ancestor', ancestorLabel: getRelName(path), layoutId: ancestorLayoutId });

            const nextRange = range / 2;
            
            if (p.fatherId) {
                // Father (Top in Horizontal, Left in Vertical)
                const fOffset = state.isHorizontal ? y - nextRange : x - nextRange;
                const fatherLayoutId = `ancestor_${p.fatherId}_${gen + 1}_${path}f`;
                addAncestor(p.fatherId, gen + 1, path + "f", fOffset, nextRange);
                // [เชื่อมด้วย UUID]
                connections.push({ fromUUID: ancestorLayoutId, toUUID: fatherLayoutId });
            }
            
            if (p.motherId) {
                // Mother (Bottom in Horizontal, Right in Vertical)
                const mOffset = state.isHorizontal ? y + nextRange : x + nextRange;
                const motherLayoutId = `ancestor_${p.motherId}_${gen + 1}_${path}m`;
                addAncestor(p.motherId, gen + 1, path + "m", mOffset, nextRange);
                // [เชื่อมด้วย UUID]
                connections.push({ fromUUID: ancestorLayoutId, toUUID: motherLayoutId });
            }
        }

        // Initial Range Calculation
        // Level 4 needs 16 slots. Range should be big enough to separate leaf nodes.
        const initialRange = (Math.pow(2, maxGen-1)) * (state.isHorizontal ? ANCESTOR_CONFIG.nodeHeight : ANCESTOR_CONFIG.nodeWidth) * 0.8; 
        
        addAncestor(rootId, 0, "", 0, initialRange);
        
        // Convert old connection format to new UUID format for Ancestor View (since the build uses the simplified object)
        const finalConnections = connections.map(c => ({ 
            fromUUID: c.fromUUID, 
            toUUID: c.toUUID, 
            isSpouse: false 
        }));
        
        return { nodes, connections: finalConnections };
    }

    // [แก้ไข: ฟังก์ชันนี้ถูกแทนที่เพื่อแก้ปัญหาเส้นไขว้]
    function calculateTreeLayout(rootId, memberList) {
        if(!rootId) return { nodes:[], connections:[] };
        
        // [เพิ่มใหม่] ฟังก์ชันสร้าง ID ชั่วคราวสำหรับแต่ละ "กล่อง" บนหน้าจอ
        const uuid = () => 'layout_' + Math.random().toString(36).substr(2, 9);
        
        // Priority 1: Use Birth Year for children sorting (oldest first, i.e., left to right)
        const childSortFn = (a, b) => {
            const aYear = parseInt(a.birthYear) || Infinity;
            const bYear = parseInt(b.birthYear) || Infinity;
            if (aYear !== bYear) return aYear - bYear;
            return a.id.localeCompare(b.id); // Secondary sort by ID for stability
        };
        
        const config = state.isHorizontal ? {...BASE_CONFIG, gapX: 40, gapY: 250} : BASE_CONFIG;
        const nodes = []; 
        const connections = []; // จะเก็บ { fromUUID, toUUID, isSpouse }
        const getP = (id) => memberList.find(m => m.id === id);

        function build(pid, level) {
            const p = getP(pid);
            if(!p) return { width: config.nodeWidth, nodes: [] };

            // [เพิ่มใหม่] สร้าง Layout ID เฉพาะสำหรับร่างนี้ (ตัวเอง)
            const myLayoutId = uuid();

            let spouses = (p.spouseIds || []).map(id => getP(id)).filter(s => s);
            const children = memberList.filter(m => m.fatherId === pid || m.motherId === pid)
                                       .sort(childSortFn); 

            const groups = [];
            spouses.forEach(s => {
                const kids = children.filter(c => c.fatherId === s.id || c.motherId === s.id);
                groups.push({ spouse: s, children: kids });
            });

            const accountedChildrenIds = new Set(groups.flatMap(g => g.children.map(c => c.id)));
            const loneChildren = children.filter(c => !accountedChildrenIds.has(c.id));
            if (loneChildren.length > 0) { groups.push({ spouse: null, children: loneChildren }); }
            
            if (groups.length === 0) { 
                return { 
                    width: config.nodeWidth, 
                    nodes: [{ data: p, x: 0, y: 0, type: 'root', layoutId: myLayoutId }] // [เพิ่ม layoutId]
                }; 
            }

            let totalSubtreeWidth = 0;
            const groupLayouts = groups.map(g => {
                let childrenBlockWidth = 0;
                const childResults = [];
                if (g.children.length > 0) {
                    g.children.forEach(child => {
                        const res = build(child.id, level + 1);
                        // [เพิ่มใหม่] เก็บ Layout ID ของลูกไว้เชื่อมเส้น
                        const childRootNode = res.nodes.find(n => n.type === 'root' && n.data.id === child.id); 
                        childResults.push({ ...res, childRootLayoutId: childRootNode ? childRootNode.layoutId : null });
                        childrenBlockWidth += res.width + config.gapX;
                    });
                    childrenBlockWidth -= config.gapX; 
                }
                const groupWidth = Math.max(g.spouse ? config.nodeWidth : 0, childrenBlockWidth);
                return { group: g, width: groupWidth, childResults };
            });

            totalSubtreeWidth = groupLayouts.reduce((acc, gl) => acc + gl.width + config.spouseGap, 0);
            if (groupLayouts.length > 0) totalSubtreeWidth -= config.spouseGap;
            totalSubtreeWidth = Math.max(totalSubtreeWidth, config.nodeWidth); 

            const localNodes = [];
            const rootX = totalSubtreeWidth / 2 - config.nodeWidth / 2;
            
            // [เพิ่มใหม่] ใส่ layoutId ลงใน Node ตัวเอง
            localNodes.push({ data: p, x: rootX, y: 0, type: 'root', layoutId: myLayoutId });

            let currentX = 0;
            groupLayouts.forEach(gl => {
                const g = gl.group;
                const groupCenterX = currentX + gl.width / 2;
                
                if (g.spouse) {
                    const spouseX = groupCenterX - config.nodeWidth / 2;
                    const spouseLayoutId = uuid(); // [เพิ่มใหม่] สร้างร่างแยกให้คู่สมรส

                    localNodes.push({ 
                        data: g.spouse, 
                        x: spouseX, 
                        y: config.gapY, 
                        type: 'spouse', 
                        partnerId: pid,
                        layoutId: spouseLayoutId // [เพิ่มใหม่]
                    });

                    // [เพิ่มใหม่] เชื่อมเส้นโดยใช้ UUID แทน ID ข้อมูล
                    connections.push({ fromUUID: myLayoutId, toUUID: spouseLayoutId, isSpouse: true });
                    
                    let childX = currentX + (gl.width - (gl.childResults.reduce((a,c)=>a+c.width+config.gapX,0) - config.gapX))/2;
                    if (gl.childResults.length === 0) childX = currentX; 

                    gl.childResults.forEach(res => {
                        // [เพิ่ม layoutId ใน Node ลูกทั้งหมด]
                        res.nodes.forEach(n => {
                            localNodes.push({ ...n, x: n.x + childX, y: n.y + config.gapY * 2 });
                        });
                        
                        // [เพิ่มใหม่] เชื่อมเส้นจากร่างแยกคู่สมรส ลงไปหาลูก
                        if (res.childRootLayoutId) { 
                            connections.push({ fromUUID: spouseLayoutId, toUUID: res.childRootLayoutId, isSpouse: false }); 
                        } 
                        childX += res.width + config.gapX;
                    });

                } else {
                    let childX = currentX + (gl.width - (gl.childResults.reduce((a,c)=>a+c.width+config.gapX,0) - config.gapX))/2;
                    gl.childResults.forEach(res => {
                        // [เพิ่ม layoutId ใน Node ลูกทั้งหมด]
                        res.nodes.forEach(n => {
                            localNodes.push({ ...n, x: n.x + childX, y: n.y + config.gapY * 2 });
                        });
                        
                        // [เพิ่มใหม่] เชื่อมเส้นจากตัวเอง (Main Parent) ลงไปหาลูก
                        if (res.childRootLayoutId) { 
                            connections.push({ fromUUID: myLayoutId, toUUID: res.childRootLayoutId, isSpouse: false }); 
                        }
                        childX += res.width + config.gapX;
                    });
                }
                currentX += gl.width + config.spouseGap;
            });
            return { width: totalSubtreeWidth, nodes: localNodes };
        }
        const treeData = build(rootId, 0);
        return { nodes: treeData.nodes, connections };
    }

    // ================= DRAWING =================
    function drawNode(node, container) {
        let config = BASE_CONFIG;
        if (state.treeViewType === 'ancestors') config = ANCESTOR_CONFIG;
        else if (state.isHorizontal) config = {...BASE_CONFIG, gapX: 40, gapY: 250};

        let x = node.x, y = node.y;
        
        // MODIFICATION: Only apply coordinate swap for NON-ANCESTOR view
        if (state.isHorizontal && state.treeViewType !== 'ancestors') { x = node.y; y = node.x; }

        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.setAttribute("transform", `translate(${x},${y})`);
        g.style.cursor = "pointer";
        g.onclick = (e) => { e.stopPropagation(); showDetail(node.data.id); };
        
        const fo = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
        fo.setAttribute("width", config.nodeWidth); fo.setAttribute("height", config.nodeHeight);
        
        const p = node.data;
        const isDead = !p.isAlive;
        const isExMonarchAlive = p.isMonarch && p.isExMonarch && p.isAlive; // NEW: Ex-Monarch
        const deathTerm = isDead ? getDeathTerm(p) : "";
        let borderClass = p.gender === 'M' ? "border-male" : "border-female";
        // MODIFICATION: Check isMonarch: true to apply King/Queen border
        if(p.isMonarch) borderClass = "border-king"; 
        else if(p.isQueenConsort) borderClass = "border-queen";
        
        let imgClass = "";
        if(isDead) {
            // Note: The isMonarch flag is now intentionally kept true even if the King is deceased, 
            // per user request. We rely on isAlive for the display of death status.
            if(p.isMonarch) { borderClass = "border-dead-royal"; imgClass = "img-grayscale"; } 
            else { borderClass = "border-dead"; imgClass = "img-grayscale"; }
        } else if (isExMonarchAlive) { 
             // NEW: Apply King death border but keep image color
             borderClass = "border-dead-royal"; 
             imgClass = "img-normal"; 
        }
        
        const treeName = getTreeNodeName(p); 
        const showCrown = (p.isMonarch || p.isQueenConsort);
        
        const isFlash = state.highlightIds.includes(p.id);
        const flashClass = isFlash ? "node-flash" : "";
        
        let badgeHTML = "";
        if (state.treeViewType === 'ancestors' && node.ancestorLabel) {
            badgeHTML += `<div class="ancestor-label">${node.ancestorLabel}</div>`;
        }
        
        if (p.isMonarch && p.useReignName && p.reignNameBase && !p.isExMonarch) { // Only show reign name badge for active monarch
            let reignTxt = p.reignNameBase;
            const autoNum = getReignNameRank(p);
            if(autoNum) reignTxt += `ที่ ${toThaiNumerals(autoNum)}`;
            if(p.globalReignNumber) reignTxt += ` (ร.${toThaiNumerals(p.globalReignNumber)})`;
            badgeHTML += `<div class="badge-monarch truncate w-full text-center mt-1">${reignTxt}</div>`;
        } else if (p.isExMonarch && p.isAlive) { // NEW: Show Ex-Monarch badge
            const reignNum = p.globalReignNumber ? `ร. ${toThaiNumerals(p.globalReignNumber)}` : '';
            badgeHTML += `<div class="badge-krom bg-purple-100 text-purple-700 border-purple-300 truncate w-full text-center mt-1">อดีตพระมหากษัตริย์ ${reignNum}</div>`;
        } else if (p.isHeir) {
             badgeHTML += `<div class="badge-heir truncate w-full text-center mt-1">รัชทายาทลำดับที่ ${toThaiNumerals(p.heirOrder)}</div>`;
        } else if (!p.isMonarch && p.kromRank) {
            // NOTE: Krom Rank is kept in node badge, but removed from full name display (per request)
            badgeHTML += `<div class="badge-krom truncate w-full text-center mt-1">${p.kromRank}${p.kromTitle||''}</div>`;
        }
        
        // --- MODIFICATION FOR RULE 2: Royal Surname Badge (Removed from Node) ---
        // Per user request, the Royal Surname badge is REMOVED from the node to fulfill: 
        // "ป้ายกำกับราชสกุลไม่แสดงในผัง(ทั้งต้นสกุลและเชื้อสาย)"
        // --- END MODIFICATION ---

        const div = document.createElement("div");
        div.className = `node-box ${borderClass} ${flashClass} ${state.viewRootId === p.id ? 'focused' : ''}`;
        div.innerHTML = `
            <div class="relative mb-1">
                <img src="${p.image || (p.gender==='M'?DEFAULT_IMG_MALE:DEFAULT_IMG_FEMALE)}" class="w-10 h-10 rounded-full border border-white shadow-sm object-cover bg-slate-100 ${imgClass}">
                ${showCrown ? `<i class="fa-solid fa-crown absolute -top-1 -right-1 text-xs ${p.isAlive && !p.isExMonarch ?'text-yellow-500':'text-slate-600'} bg-white rounded-full p-0.5 shadow-sm"></i>` : ''}
            </div>
            <div class="text-[11px] font-bold text-center leading-tight truncate w-full px-1 ${p.isMonarch?'text-amber-700':'text-slate-700'}">${treeName}</div>
            ${badgeHTML}
            ${isDead ? `<div class="absolute top-1 left-1 text-[8px] bg-slate-800 text-white px-1.5 py-0.5 rounded shadow-sm opacity-90">${deathTerm}</div>` : ''}
        `;
        fo.appendChild(div); g.appendChild(fo); container.appendChild(g);
    }

    function drawLink(n1, n2, isSpouse, container) {
        let config = BASE_CONFIG;
        if (state.treeViewType === 'ancestors') config = ANCESTOR_CONFIG;
        else if (state.isHorizontal) config = {...BASE_CONFIG, gapX: 40, gapY: 250};

        const getC = (n, type) => {
            let nx = n.x, ny = n.y;
            
            // Fix: In ancestor view, use raw calculated coordinates (no swap)
            if (state.treeViewType !== 'ancestors' && state.isHorizontal) { nx = n.y; ny = n.x; }

            if (state.treeViewType === 'ancestors') {
                 // For ancestor view, we determine connection points based on state.isHorizontal
                if (state.isHorizontal) { // Horizontal Ancestor Layout (Parent right of child)
                    // n1 (child) connects from right side, n2 (parent) connects to left side
                    if (type === 'from') return { x: nx + config.nodeWidth, y: ny + config.nodeHeight/2 }; // Right side
                    if (type === 'to') return { x: nx, y: ny + config.nodeHeight/2 }; // Left side
                } else { // Vertical Ancestor Layout (Parent above child)
                    // n1 (child) connects from top side, n2 (parent) connects to bottom side
                    if (type === 'from') return { x: nx + config.nodeWidth/2, y: ny }; // Top side
                    if (type === 'to') return { x: nx + config.nodeWidth/2, y: ny + config.nodeHeight }; // Bottom side
                }
            } else {
                 // Standard Tree View (Parent top, Child bottom)
                 if (state.isHorizontal) {
                    if(type==='bottom') return {x: nx+config.nodeWidth, y: ny+config.nodeHeight/2}; 
                    if(type==='top') return {x: nx, y: ny+config.nodeHeight/2}; 
                 } else {
                    if(type==='bottom') return {x: nx+config.nodeWidth/2, y: ny+config.nodeHeight};
                    if(type==='top') return {x: nx+config.nodeWidth/2, y: ny};
                 }
            }
            return {x: nx, y: ny};
        };

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        // Updated: Use different class for spouse and child connections for themed coloring
        path.setAttribute("class", `connector ${isSpouse ? 'connector-spouse' : 'connector-child'}`);
        
        if (state.highlightIds.includes(n1.data.id) && state.highlightIds.includes(n2.data.id)) {
            path.style.stroke = "#ef4444";
            path.style.strokeWidth = "3px";
            path.style.strokeDasharray = "5,5";
        }

        let p1, p2, d;
        
        if (state.treeViewType === 'ancestors') {
            p1 = getC(n1, 'from'); // Child (Lower Generation)
            p2 = getC(n2, 'to');   // Parent (Higher Generation)
            
            if (state.isHorizontal) {
                // Horizontal Ancestor Layout: Left-to-Right curve
                const midX = (p1.x + p2.x)/2;
                d = `M ${p1.x} ${p1.y} C ${midX} ${p1.y}, ${midX} ${p2.y}, ${p2.x} ${p2.y}`;
            } else {
                 // Vertical Ancestor Layout: Bottom-to-Top curve
                const midY = (p1.y + p2.y)/2;
                d = `M ${p1.x} ${p1.y} C ${p1.x} ${midY}, ${p2.x} ${midY}, ${p2.x} ${p2.y}`;
            }
            
        } else {
            if(isSpouse) {
                p1 = getC(n1, 'bottom'); p2 = getC(n2, 'top');
                if(state.isHorizontal) { 
                    const midX = (p1.x + p2.x)/2; 
                    d = `M ${p1.x} ${p1.y} C ${midX} ${p1.y}, ${midX} ${p2.y}, ${p2.x} ${p2.y}`; 
                } else { 
                    const midY = (p1.y + p2.y)/2; 
                    d = `M ${p1.x} ${p1.y} C ${p1.x} ${midY}, ${p2.x} ${midY}, ${p2.x} ${p2.y}`; 
                }
                
                // Draw heart icon for spouse connection
                const mx = (p1.x + p2.x)/2; const my = (p1.y + p2.y)/2;
                const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                txt.setAttribute("class", "heart-icon"); txt.setAttribute("text-anchor", "middle"); txt.setAttribute("dominant-baseline", "middle"); txt.textContent = "❤";
                txt.setAttribute("x", mx); txt.setAttribute("y", my);
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", mx); circle.setAttribute("cy", my); circle.setAttribute("r", 8); circle.setAttribute("fill", "#fff");
                container.appendChild(circle); container.appendChild(txt);
            } else {
                p1 = getC(n1, 'bottom'); p2 = getC(n2, 'top');
                if(state.isHorizontal) { 
                    const midX = (p1.x + p2.x)/2; 
                    d = `M ${p1.x} ${p1.y} C ${midX} ${p1.y}, ${midX} ${p2.y}, ${p2.x} ${p2.y}`; 
                } else { 
                    const midY = (p1.y + p2.y)/2; 
                    d = `M ${p1.x} ${p1.y} C ${p1.x} ${midY}, ${p2.x} ${midY}, ${p2.x} ${p2.y}`; 
                }
            }
        }
        path.setAttribute("d", d); container.appendChild(path);
    }

    // ================= UTILS & HELPERS =================
    function toThaiNumerals(num) {
        if(num === null || num === undefined) return '';
        const thai = ['๐','๑','๒','๓','๔','๕','๖','๗','๘','๙'];
        return num.toString().split('').map(d => thai[d]||d).join('');
    }
    function getReignNameRank(p) {
        if(!p.isMonarch || !p.useReignName || !p.reignNameBase) return null;
        const sameName = state.members
            .filter(m => m.isMonarch && m.useReignName && m.reignNameBase === p.reignNameBase)
            .sort((a,b) => (parseInt(a.reignStart)||0) - (parseInt(b.reignStart)||0) || a.id.localeCompare(b.id));
        return sameName.findIndex(m => m.id === p.id) + 1;
    }
    function getDisplayRank(rank) {
        if(!rank) return '';
        if(rank.includes('เจ้าฟ้า') || rank.includes('พระองค์เจ้า')) {
            return rank.split(' ')[0]; 
        }
        return rank;
    }
    
    function isCommonerDescendant(p) {
        if (!p.royalRank) return true;
        return p.royalRank.includes('สามัญชน') || p.royalRank.includes('หม่อมราชวงศ์') || p.royalRank.includes('หม่อมหลวง');
    }

    /**
     * UPDATED LOGIC: Implements all name display rules as requested, including surname.
     */
    function getFullDisplayTitle(p) {
        if (!p) return "";
        let finalNameParts = [];
        
        // --- Condition for Hiding Surname ---
        if (p.hideSurname) {
             // If surname is explicitly hidden, skip all surname logic below.
        } else {
             // --- 1. Surname Inheritance/Auto-Population ---
             // Only auto-inherit if it's NOT a founder and NOT explicitly a commoner outside the royal lineage
             // (Otherwise rely on saved/inherited values in p.royalSurname or p.surname)
             if (!p.royalSurname) {
                 let primaryParent = state.members.find(m => m.id === p.fatherId);
                 // If mother is higher rank or female monarch/heir, check mother's lineage first.
                 if (p.motherId) {
                      const mother = state.members.find(m => m.id === p.motherId);
                      const isMonarchMother = mother?.isMonarch || (mother?.isHeir && parseInt(mother?.heirOrder) === 1);
                      if (isMonarchMother || p.gender === 'F' && mother?.royalRank) {
                           primaryParent = mother;
                      }
                 }
                 
                 // If the primary parent has a royal surname lineage, inherit it.
                 if (primaryParent?.royalSurname) {
                     p.royalSurname = primaryParent.royalSurname;
                 } else if (primaryParent?.royalRank.includes('สามัญชน') && primaryParent.surname) {
                      // If parent is a non-royal commoner who married in, they keep their commoner name, but the child is outside the *royal* lineage surname flow unless the princess rule applies.
                 }
             }
        }
        // --- END Surname Inheritance/Auto-Population ---

        // Rule 3 Exceptions: King, Queen Consort, Heir Apparent (No Royal Rank, No Krom)
        const isHighRoyalTitle = p.isMonarch || p.isQueenConsort || (p.isHeir && parseInt(p.heirOrder) === 1); 

        // --- 1. Prefix (คำนำหน้าชื่อ) ---
        if (p.titlePrefix) {
            finalNameParts.push(p.titlePrefix);
        }

        // --- 2. Royal Rank (อิสริยยศ) and Name (ชื่อ) ---
        let rankAndName = "";

        // Determine if the rank should be explicitly shown (not hidden, not a high royal title)
        // NOTE: M.R.W. and M.L. should show their full rank/prefix in the full title (Rule 3)
        const shouldShowRoyalRank = !p.hideRoyalRank && !isCommonerDescendant(p) && !isHighRoyalTitle;
        
        if (shouldShowRoyalRank) {
            rankAndName += getDisplayRank(p.royalRank); // e.g., เจ้าฟ้า, พระองค์เจ้า
        }
        
        rankAndName += p.name;
        finalNameParts.push(rankAndName);
        
        // --- 2.5 Surname Logic (Display) ---
        if (!p.hideSurname) {
            const isRoyalLineageSurname = !!p.royalSurname && p.royalSurname.trim() !== '';
            const isGeneralCommonerPrefix = ['นาย', 'นาง', 'นางสาว', 'คุณ', 'คุณหญิง', 'ท่านผู้หญิง'].includes(p.titlePrefix);
            const isMRWMLPrefix = ['หม่อมเจ้า', 'หม่อมราชวงศ์', 'หม่อมหลวง'].includes(p.titlePrefix); // Include หม่อมเจ้า here for surname display rule
            
            if (isRoyalLineageSurname) {
                
                // A. If M.C., M.R.W., or M.L. (Must display Royal Surname, no ณ)
                if (isMRWMLPrefix) {
                    if (p.royalSurname) finalNameParts.push(p.royalSurname);
                } 
                // B. If general commoner prefix (นาย, นาง, คุณ, etc.) and has royal lineage (Must display with ณ)
                else if (isGeneralCommonerPrefix) {
                     if (p.royalSurname) finalNameParts.push(`${p.royalSurname} ณ ${state.kingdomName}`);
                }
                // C. For other high royal ranks (เจ้าฟ้า, พระองค์เจ้า) surnames are typically suppressed by custom unless overridden by prefix (already checked above) or explicitly set to be shown (which we don't have a separate toggle for yet).
                
            } else if (p.royalRank === 'สามัญชน' && p.surname) {
                 // Case D: Explicit Commoner Surname (Non-Royal Lineage)
                 // Rule: Non-Royal Lineage Surname MUST NOT have the ณ suffix.
                 finalNameParts.push(p.surname);
            }
        }
        // --- End Surname Logic (Display) ---

        // --- 3. Suffix (สร้อยพระนาม) ---
        if (p.titleSuffix) {
            finalNameParts.push(p.titleSuffix);
        }
        
        // --- 4. Krom Rank and Title (ยศกรมและราชทินนามกรม) ---
        const showKrom = !isHighRoyalTitle && p.kromRank; 
        
        if (showKrom) {
            finalNameParts.push(p.kromRank + (p.kromTitle || "")); 
        }
        
        // --- 5. Monarch Spouse Context ---
        const activeMonarch = state.members.find(m => m.isMonarch && m.isAlive && !m.isExMonarch);
        const isCurrentMonarchConsort = activeMonarch && (activeMonarch.spouseIds || []).includes(p.id);
        
        if (p.monarchSpouseContext && !isCurrentMonarchConsort) {
            finalNameParts.push(p.monarchSpouseContext);
        }

        // --- 6. Reign Name (สำหรับกษัตริย์ที่มีนามแผ่นดิน) ---
        if (p.isMonarch && p.useReignName && p.reignNameBase && !p.isExMonarch) {
            let reignStr = p.reignNameBase;
            if(p.eraName) reignStr += " " + p.eraName;
            const autoNum = getReignNameRank(p);
            if(autoNum) reignStr += "ที่ " + toThaiNumerals(autoNum);
            finalNameParts.push(reignStr);
        }
        
        // --- 7. Ex-Monarch Suffix (NEW RULE) ---
        // Apply only if they are marked as Ex-Monarch AND are currently alive (suffix is removed upon death)
        if (p.isMonarch && p.isExMonarch && p.isAlive) {
            const reignLabel = p.globalReignNumber ? `รัชกาลที่ ${toThaiNumerals(p.globalReignNumber)}` : '';
            // MODIFICATION: Use requested phrasing: อดีตพระมหากษัตริย์รัชกาลที่{เลขรัชกาล}
            finalNameParts.push(`อดีตพระมหากษัตริย์${reignLabel}`);
        }
        // --- END NEW RULE ---

        // Rule: แสดงผลเป็น คำนำหน้า ชื่อ สกุล ณ{ชื่ออาณาจักร} ห่างกันด้วย space
        return finalNameParts.filter(s => s && s.trim() !== "").join(" ");
    }


    function getNicknameWithPrefix(p) {
        if(!p.nickname) return '-';
        let prefix = '';
        const r = p.royalRank || '';
        if(r.includes('เจ้าฟ้า (ชั้นเอก)')) prefix = 'ทูลกระหม่อม';
        else if(r.includes('เจ้าฟ้า')) prefix = 'สมเด็จ'; 
        else if(r.includes('พระองค์เจ้า (ชั้นเอก)') || r.includes('พระองค์เจ้า (ชั้นโท)')) prefix = 'เสด็จ';
        else if(r.includes('หม่อมเจ้า')) prefix = p.gender === 'M' ? 'ท่านชาย' : 'ท่านหญิง';
        return prefix + p.nickname;
    }

    /**
     * Retrieves the name displayed inside the tree node box.
     * Per user request, M.R.W. and M.L. (and high royal prefixes) are NOT shown here, only the name.
     */
    function getTreeNodeName(p) { 
        // Per user request: Do not show M.R.W. or M.L. or any other rank/prefix in the tree node itself.
        // It should only show the name. The full rank is available in the popup.
        return p.name || "-"; 
    }
    
    function getGlobalReignLabel(p) {
        if(p.globalReignNumber) return `รัชกาลที่ ${toThaiNumerals(p.globalReignNumber)}`;
        return '';
    }
    function getDeathTerm(p) {
        if(p.hasUmbrella) {
            if(p.umbrellaType.includes('นพดล') || p.umbrellaType.includes('สัปตดล')) return "สวรรคต";
            if(p.umbrellaType.includes('เบญจดล')) return "ทิวงคต"; 
        }
        // MODIFICATION: Use p.isMonarch (historical) instead of p.isMonarch || p.isQueenConsort || p.isExMonarch
        if(p.isMonarch || p.isQueenConsort) return "สวรรคต"; 
        const rank = p.royalRank || '';
        if((p.relationship||'').includes('บาทบริจาริกา')) return "อสัญกรรม";
        if(rank.includes('เจ้าฟ้า')) return "ทิวงคต";
        if(rank.includes('พระองค์เจ้า')) return "สิ้นพระชนม์";
        if(rank.includes('หม่อมเจ้า')) return "สิ้นชีพิตักษัย";
        if(rank.includes('เจ้าประเทศราช')) return "พิลาลัย";
        return "เสียชีวิต";
    }
    function generateRoyalId(gender, rankName) {
        const d1 = gender === 'M' ? '1' : '2';
        const d2 = RANK_CODES[rankName] || 'A';
        const d3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(Math.random()*26));
        const d4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(Math.random()*26));
        return `${d1}${d2}${d3}${d4}${Math.floor(Math.random()*1000000)}`;
    }
    function updateAutoId() {
        try {
            if (document.getElementById('p_isEditMode').value === 'true') return;
            const gEl = document.querySelector('input[name="gender"]:checked');
            const gender = gEl ? gEl.value : 'M';
            const rank = document.getElementById('p_royalRank').value || 'สามัญชน';
            document.getElementById('p_id').value = generateRoyalId(gender, rank);
        } catch(e) { }
    }

    // New: Function to check and update consort prefix
    function checkConsortMotherhood(person) {
        if (person.gender !== 'F') return person;

        const rel = person.relationship || '';
        let prefix = person.titlePrefix || '';
        
        // 1. Check if the person is a royal consort (บาทบริจาริกา)
        if (rel.includes('บาทบริจาริกา')) {
            
            // 2. Check if the current prefix is เจ้าจอม, เจ้าคุณจอม, เจ้าจอมมารดา, or เจ้าคุณจอมมารดา
            if (prefix === 'เจ้าจอม' || prefix === 'เจ้าคุณจอม' || prefix === 'เจ้าจอมมารดา' || prefix === 'เจ้าคุณจอมมารดา') {
                
                // 3. Check for children (motherId matches this person)
                const hasChildren = state.members.some(m => m.motherId === person.id);
                
                if (hasChildren) {
                    if (prefix === 'เจ้าจอม') {
                        person.titlePrefix = 'เจ้าจอมมารดา';
                        showToast(`เลื่อนยศอัตโนมัติ: ${person.name} เป็น เจ้าจอมมารดา`);
                    } else if (prefix === 'เจ้าคุณจอม') {
                        person.titlePrefix = 'เจ้าคุณจอมมารดา';
                        showToast(`เลื่อนยศอัตโนมัติ: ${person.name} เป็น เจ้าคุณจอมมารดา`);
                    }
                } else {
                    // Ensure correct default if no children (demote if needed)
                    if (prefix === 'เจ้าจอมมารดา') {
                         person.titlePrefix = 'เจ้าจอม';
                    } else if (prefix === 'เจ้าคุณจอมมารดา') {
                         person.titlePrefix = 'เจ้าคุณจอม';
                    }
                }
            }
        }
        return person;
    }

    /**
     * Calculates the appropriate default Royal Rank and Title Prefix for a child
     * of the current reigning monarch, based on the mother's status/lineage.
     */
    function calculateChildRank(fatherId, motherId, gender) {
        const defaultRank = 'พระองค์เจ้า (ชั้นเอก)';
        const defaultRel = gender === 'M' ? 'พระราชโอรส' : 'พระราชธิดา';
        
        const monarchParent = state.members.find(m => m.id === fatherId);
        const otherParent = state.members.find(m => m.id === motherId);

        // NEW: Determine Royal Surname for the child
        let royalSurname = '';
        if (monarchParent) {
            // Royal children inherit the Royal Surname from the bloodline (Monarch or other parent)
            royalSurname = monarchParent.royalSurname || otherParent?.royalSurname || monarchParent.surname || otherParent?.surname || ''; 
        }

        // If Monarch parent is not the current Monarch (or not found/invalid), use fallback
        if (!monarchParent || !monarchParent.isMonarch) {
            return { royalRank: defaultRank, titlePrefix: '', relationship: defaultRel, royalSurname, surname: '' };
        }

        // --- Rule 3: Mother is Royal Consort (บาทบริจาริกา/เจ้าจอมมารดา) ---
        if (otherParent && (otherParent.relationship || '').includes('บาทบริจาริกา')) {
            const prefix = gender === 'M' ? 'พระเจ้าลูกยาเธอ' : 'พระเจ้าลูกเธอ';
            return { royalRank: 'พระองค์เจ้า (ชั้นเอก)', titlePrefix: prefix, relationship: defaultRel, royalSurname, surname: '' };
        }

        // --- Other Parent must be a royal bloodline for higher rank (not a commoner wife) ---
        if (!otherParent || (otherParent.royalRank || '').includes('สามัญชน')) {
            const prefix = gender === 'M' ? 'พระเจ้าลูกยาเธอ' : 'พระเจ้าลูกเธอ';
            return { royalRank: defaultRank, titlePrefix: prefix, relationship: defaultRel, royalSurname, surname: '' };
        }

        // --- Lineage Check (Other Parent is Royal) ---
        let motherRankLevel = 0; // 1 = Daughter of King, 2 = Grandchild/Further of King
        
        let mFather = state.members.find(m => m.id === otherParent.fatherId);
        let mMother = state.members.find(m => m.id === otherParent.motherId);
        
        if ((mFather?.isMonarch && mFather.id !== monarchParent.id) || (mMother?.isMonarch && mMother.id !== monarchParent.id)) {
            motherRankLevel = 1;
        }

        if (motherRankLevel === 0) {
            const grandparents = [mFather, mMother].filter(p => p);
            let isGrandchildOfMonarch = false;
            
            for (const gp of grandparents) {
                const ggf = state.members.find(m => m.id === gp.fatherId);
                const ggm = state.members.find(m => m.id === gp.motherId);
                
                if ((ggf?.isMonarch && ggf.id !== monarchParent.id) || (ggm?.isMonarch && ggm.id !== monarchParent.id)) {
                    isGrandchildOfMonarch = true;
                    break;
                }
            }

            if (isGrandchildOfMonarch) {
                motherRankLevel = 2; 
            }
        }


        // --- Apply Rank based on Mother's Lineage ---
        let royalRank = defaultRank;
        let titlePrefix;
        
        if (motherRankLevel === 1) {
            royalRank = 'เจ้าฟ้า (ชั้นเอก)';
            titlePrefix = gender === 'M' ? 'สมเด็จพระเจ้าลูกยาเธอ' : 'สมเด็จพระเจ้าลูกเธอ';
        } else if (motherRankLevel === 2) {
            royalRank = 'เจ้าฟ้า (ชั้นโท)';
            titlePrefix = gender === 'M' ? 'สมเด็จพระเจ้าลูกยาเธอ' : 'สมเด็จพระเจ้าลูกเธอ';
        } else if (otherParent.royalRank && (otherParent.royalRank.includes('เจ้าฟ้า') || otherParent.royalRank.includes('พระองค์เจ้า'))) {
            royalRank = 'พระองค์เจ้า (ชั้นเอก)';
            titlePrefix = gender === 'M' ? 'พระเจ้าลูกยาเธอ' : 'พระเจ้าลูกเธอ';
        } else {
             titlePrefix = gender === 'M' ? 'พระเจ้าลูกยาเธอ' : 'พระเจ้าลูกเธอ';
        }

        return { royalRank, titlePrefix, relationship: defaultRel, royalSurname, surname: '' };
    }


    /**
     * Calculates the appropriate Royal Rank, Title Prefix, and Surname for a child
     * who is NOT a direct child of the current reigning monarch.
     * Implements rules for commoner marriage and MR/ML generation.
     */
    function calculateChildRankGeneric(fatherId, motherId, gender) {
        const defaultCommonerRank = 'สามัญชน';
        const defaultCommonerRel = 'สามัญชน';
        
        const father = state.members.find(m => m.id === fatherId);
        const mother = state.members.find(m => m.id === motherId);
        
        // Default to commoner status
        let royalRank = defaultCommonerRank;
        let titlePrefix = gender === 'M' ? 'นาย' : 'นางสาว';
        let relationship = defaultCommonerRel;
        let royalSurname = '';
        let surname = '';

        // --- 1. Check for Royal Male Bloodline (Father is Royal) ---
        if (father && !isCommonerDescendant(father)) {
            const fatherRank = father.royalRank || 'สามัญชน';
            // Royal descent: Inherit the Royal Surname from Father
            royalSurname = father.royalSurname || father.surname || '';
            surname = ''; // Clear explicit commoner surname on auto rank, reliance is on royalSurname
            
            // A. Father is 'หม่อมเจ้า'
            if (fatherRank.includes('หม่อมเจ้า')) {
                royalRank = 'หม่อมราชวงศ์';
                titlePrefix = 'หม่อมราชวงศ์'; 
                relationship = 'สามัญชน';
            } 
            // B. Father is 'หม่อมราชวงศ์' (NEW RULE: MRW -> ML)
            else if (fatherRank.includes('หม่อมราชวงศ์')) {
                royalRank = 'หม่อมหลวง';
                titlePrefix = 'หม่อมหลวง'; 
                relationship = 'สามัญชน';
            } 
            // C. Father is a higher-rank Prince (Chao Fa/Phra Ong Chao) but NOT the King
            else if (fatherRank.includes('เจ้าฟ้า') || fatherRank.includes('พระองค์เจ้า')) {
                 // Children of Princes/Princesses (not the King) get หม่อมเจ้า rank
                royalRank = 'หม่อมเจ้า';
                titlePrefix = 'หม่อมเจ้า';
                relationship = 'พระอนุวงศ์';
            } 
             // D. Father is หม่อมหลวง or lower (Child is commoner)
            else if (fatherRank.includes('หม่อมหลวง') || isCommonerDescendant(father)) {
                royalRank = defaultCommonerRank;
                titlePrefix = gender === 'M' ? 'นาย' : 'นางสาว';
                relationship = defaultCommonerRel;
            }
        }
        
        // --- 2. Check for Royal Female Bloodline + Commoner Male (Rule: Child is Commoner) ---
        else if ((!father || isCommonerDescendant(father))) {
            if (mother && !isCommonerDescendant(mother)) {
                
                // Rule: If high-rank royal female marries commoner, child is commoner.
                // Exception: "ยกเว้นกษัตริย์หญิง หรือรัชทายาทหญิงอันดับ1" -> This function is for non-Monarch children.
                royalRank = defaultCommonerRank;
                titlePrefix = gender === 'M' ? 'นาย' : 'นางสาว';
                relationship = defaultCommonerRel;
                
                // Child inherits the royal surname lineage from the mother (if any), but is still a commoner.
                royalSurname = mother.royalSurname || '';
                surname = ''; // Clear explicit commoner surname
                
                showToast(`หมายเหตุ: ${mother.name} (${mother.royalRank}) แต่งกับสามัญชน, ลูกเป็นสามัญชน`);
            }
        }

        // Final check on title prefix for commoners (in case of manual override or fallback)
        if (royalRank === 'สามัญชน') {
            if (!titlePrefix || titlePrefix === 'หม่อมราชวงศ์' || titlePrefix === 'หม่อมหลวง') {
                 titlePrefix = gender === 'M' ? 'นาย' : 'นางสาว';
            }
        } else if (royalRank.includes('หม่อมราชวงศ์') || royalRank.includes('หม่อมหลวง')) {
            // Ensure titlePrefix matches rank for M.R.W./M.L.
             titlePrefix = royalRank.split(' ')[0];
        }

        return { royalRank, titlePrefix, relationship, royalSurname, surname };
    }

    // Helper to check if someone is a direct descendant of the Monarch (child or grandchild)
    function isDirectDescendant(ancestorId, descendantId) {
        const d = state.members.find(m => m.id === descendantId);
        if (!d) return { isChild: false, isGrandchild: false };
        
        // Check Child
        const isChild = (d.fatherId === ancestorId || d.motherId === ancestorId);
        if (isChild) return { isChild: true, isGrandchild: false };

        // Check Grandchild (Child of the Monarch's child)
        const father = state.members.find(m => m.id === d.fatherId);
        const mother = state.members.find(m => m.id === d.motherId);
        
        const isGrandchild = (father && (father.fatherId === ancestorId || father.motherId === ancestorId)) ||
                             (mother && (mother.fatherId === ancestorId || mother.motherId === ancestorId));
        
        return { isChild: false, isGrandchild: isGrandchild };
    }

    // ================= NEW SURNAME FIELD LOGIC =================
    
    function toggleSurnameFields() {
        const isFounder = document.getElementById('p_isSurnameFounder').checked;
        const rank = document.getElementById('p_royalRank').value;
        const isCommonerRank = rank === 'สามัญชน';

        document.getElementById('royalSurnameFounderPanel').classList.toggle('hidden', !isFounder);
        
        // Commoner surname input appears only if rank is commoner AND they are NOT a founder
        document.getElementById('commonerSurnamePanel').classList.toggle('hidden', !isCommonerRank || isFounder);
    }
    
    // ================= PRECEDENCE LOGIC (ระบบลำดับโปเจียม Micro Scale) =================

    function refreshAllDisplays() {
        saveState();
        updateApp(); // Call updateApp instead of just renderTable to refresh tree too
    }

    function calculatePojiamScore(person) {
        if (!person) return 0;

        // --- 1. FILTER: Exclude Consorts and Commoners from Precedence (unless Queen Consort) ---
        if (!person.isQueenConsort) {
            // Rule: ตำแหน่งบาทบริจาริกา, เจ้าจอม, เจ้าจอมมารดา, หม่อม ไม่ถูกนับในลำดับโปรเจียม
            if ((person.relationship || '').includes('บาทบริจาริกา')) {
                return 0; // IMPLEMENTATION of user's rule: บาทบริจาริกาไม่มีโปรเจียม
            }
            // Exclude Commoners and others not explicitly royalty (covers หม่อม and commoner status)
            if (person.royalRank === 'สามัญชน' || person.royalRank === 'หม่อมราชวงศ์' || person.royalRank === 'หม่อมหลวง') {
                return 0;
            }
        }

        // --- 2. ZONE A: ชนชั้นปกครอง (8,000 - 10,000) ---
        // Find Active Monarch
        const activeMonarch = state.members.find(m => m.isMonarch && m.isAlive && !m.isExMonarch);
        
        // Monarchs (Active or Ex)
        if (person.isMonarch) {
            if (person.isAlive && !person.isExMonarch) return 10000; // Active Monarch
            
            // Ex-Monarch (Alive) - Score must be lower than current Queen Consort (9800)
            if (person.isExMonarch && person.isAlive) {
                 // MODIFICATION (Rule 4): Score is 9780, placing it after current Queen Consort (9800) but above others.
                 return 9780;
            }
            
            // Deceased Monarchs 
            if (!person.isAlive) return 9900 + (parseInt(person.globalReignNumber) || 0); 
        }

        if (person.isQueenConsort) {
            const isCurrentSpouse = activeMonarch && (activeMonarch.spouseIds || []).includes(person.id);
            
            if (isCurrentSpouse) return 9800; // ราชินีปัจจุบัน (Higher than Ex-Monarch)
            else {
                let score = 9500; // Queen Consorts of previous Monarchs
                const spouses = person.spouseIds || [];
                
                const royalHusbands = state.members.filter(m => spouses.includes(m.id) && m.isMonarch);
                
                if (royalHusbands.length > 0) {
                    const husband = royalHusbands[0];
                    const rNum = parseInt(husband.globalReignNumber) || 999;
                    score += (100 - rNum);
                }
                
                return score; 
            }
        }

        const monarch = activeMonarch; // Use active monarch for proximity and high-rank spouse checks
        if (monarch && person.id !== monarch.id) {
            const hasSpecialPrefix = state.prefixScores && person.titlePrefix && state.prefixScores[person.titlePrefix] > 0;
            const hasSpecialSuffix = state.suffixScores && person.titleSuffix && state.suffixScores[person.titleSuffix] > 0;

            if (hasSpecialPrefix || hasSpecialSuffix) {
                if (person.id === monarch.motherId) return 9400;
                if (person.id === monarch.fatherId) return 9300;
                
                const father = state.members.find(m => m.id === monarch.fatherId);
                const mother = state.members.find(m => m.id === monarch.motherId);
                
                if (father) {
                    if (person.id === father.motherId) return 9200;
                    if (person.id === father.fatherId) return 9100;
                }
                if (mother) {
                    if (person.id === mother.motherId) return 9000;
                    if (person.id === mother.fatherId) return 8900;
                }
            }
        }

        const heirOrder = parseInt(person.heirOrder) || 999;
        if (person.isHeir && heirOrder === 1) {
            return 8000;
        }

        // --- 3. ZONE B: เจ้านายทั่วไป (คิดคะแนนสะสม) ---
        let score = 0;

        const rankScoreMap = {
            "เจ้าฟ้า (ชั้นเอก)": 700, "เจ้าฟ้า (ชั้นโท)": 600, "เจ้าฟ้า (ชั้นตรี)": 500,
            "พระองค์เจ้า (ชั้นเอก)": 400, "พระองค์เจ้า (ชั้นโท)": 300,
            "หม่อมเจ้า": 200, "เจ้าประเทศราช": 150, "สามัญชน": 0, "หม่อมราชวงศ์": 0, "หม่อมหลวง": 0
        };
        score += rankScoreMap[person.royalRank] || 0;

        if (state.prefixScores && person.titlePrefix && state.prefixScores[person.titlePrefix]) {
            score += parseInt(state.prefixScores[person.titlePrefix]);
        }
        if (state.suffixScores && person.titleSuffix && state.suffixScores[person.titleSuffix]) {
            score += parseInt(state.suffixScores[person.titleSuffix]);
        }

        const kromScoreMap = { "สมเด็จกรมพระ": 50, "กรมพระยา": 40, "กรมพระ": 30, "กรมหลวง": 20, "กรมขุน": 10, "กรมหมื่น": 5 };
        score += kromScoreMap[person.kromRank] || 0;
        
        if (person.hasUmbrella) {
            if (person.umbrellaType.includes("นพดล")) score += 9;
            else if (person.umbrellaType.includes("สัปตดล")) score += 7;
            else if (person.umbrellaType.includes("เบญจดล")) score += 5;
            else if (person.umbrellaType.includes("ตรีดล")) score += 3;
        }

        if (monarch && person.id !== monarch.id) {
            let proximityBonus = 0;
            if ((monarch.spouseIds || []).includes(person.id)) proximityBonus = 4;
            else if (person.fatherId === monarch.id || person.motherId === monarch.id) proximityBonus = 5;
            else if (person.fatherId && (person.fatherId === monarch.fatherId || person.motherId === monarch.motherId)) proximityBonus = 3;
            else if (person.fatherId || person.motherId) {
                 const father = state.members.find(m => m.id === person.fatherId);
                 const mother = state.members.find(m => m.id === person.motherId);
                 const fatherIsChild = father && (father.fatherId === monarch.id || father.motherId === monarch.id);
                 const motherIsChild = mother && (mother.fatherId === monarch.id || mother.motherId === monarch.id);
                 if (fatherIsChild || motherIsChild) proximityBonus = 2;
            }
            score += proximityBonus;
        }

        // ลบค่า seniority เพื่อให้คนที่ ID ต่ำ (สร้างก่อน) มีคะแนนสูงกว่า
        let seniorityScore = parseInt(person.id.substring(person.id.length - 6)) / 1000000;
        score -= seniorityScore;

        return score;
    }

    function movePrecedence(id, direction) {
        showToast("ระบบคำนวณอัตโนมัติทำงานอยู่ ไม่สามารถย้ายด้วยมือได้");
    }

    function resetPrecedence() {
        state.members.forEach(m => delete m.customPrecedence);
        saveState();
        renderTable();
        showToast("รีคำนวณลำดับเรียบร้อย");
    }

// ================= RANK MANAGER (เวอร์ชันแก้ไขในแถวตามรูปภาพ) =================
let selR = null, selP = null;
let editingItem = { type: null, value: null }; // เก็บว่ากำลังแก้ไขแถวไหนอยู่

function openRankManagementModal() { 
    editingItem = { type: null, value: null }; // รีเซ็ตสถานะแก้ไข
    renderRM(); 
    document.getElementById('rankManagementModal').classList.add('active'); 
    setTimeout(initSortableColumns, 100); 
}

// ฟังก์ชันเปิดโหมดแก้ไขในแถว
function editData(type, value) {
    editingItem = { type: type, value: value };
    renderRM();
}

// ฟังก์ชันยกเลิกการแก้ไข
function cancelInlineEdit() {
    editingItem = { type: null, value: null };
    renderRM();
}

// ฟังก์ชันบันทึกการแก้ไขจากในแถว
function saveInlineEdit(type, oldVal) {
    const nameInput = document.getElementById('inline_edit_name');
    const scoreInput = document.getElementById('inline_edit_score');
    
    const newVal = nameInput ? nameInput.value.trim() : oldVal;
    const newScore = scoreInput ? parseInt(scoreInput.value) || 0 : 0;

    if (!newVal) return showToast("กรุณากรอกชื่อ");

    if (type === 'rel') {
        state.hierarchy[newVal] = state.hierarchy[oldVal];
        if (newVal !== oldVal) delete state.hierarchy[oldVal];
        if (selR === oldVal) selR = newVal;
    } 
    else if (type === 'pre') {
        const idx = state.hierarchy[selR].prefixes.indexOf(oldVal);
        if (idx !== -1) state.hierarchy[selR].prefixes[idx] = newVal;
        if (newVal !== oldVal) {
            state.hierarchy[selR].suffixes[newVal] = state.hierarchy[selR].suffixes[oldVal];
            delete state.hierarchy[selR].suffixes[oldVal];
            if (selP === oldVal) selP = newVal;
        }
        state.prefixScores[newVal] = newScore;
        if (newVal !== oldVal) delete state.prefixScores[oldVal];
    } 
    else if (type === 'suf') {
        const idx = state.hierarchy[selR].suffixes[selP].indexOf(oldVal);
        if (idx !== -1) state.hierarchy[selR].suffixes[selP][idx] = newVal;
        state.suffixScores[newVal] = newScore;
        if (newVal !== oldVal) delete state.suffixScores[oldVal];
    }
    else if (type === 'reign') {
        const idx = state.reignNames.indexOf(oldVal);
        if (idx !== -1) state.reignNames[idx] = newVal;
    }

    editingItem = { type: null, value: null };
    saveState();
    renderRM();
    refreshAllDisplays();
    showToast("บันทึกการแก้ไขเรียบร้อย ✨");
}

function renderRM() {
    if(!state.prefixScores) state.prefixScores = {};
    if(!state.suffixScores) state.suffixScores = {};

    // 1. คอลัมน์ความสัมพันธ์
    const rl = document.getElementById('rl'); rl.innerHTML = '';
    Object.keys(state.hierarchy).forEach(k => {
        if (editingItem.type === 'rel' && editingItem.value === k) {
            rl.innerHTML += inlineEditHTML('rel', k);
        } else {
            rl.innerHTML += itemHTML('rel', k, `delData('rel','${k}')`, `selectRel('${k}')`, null, selR === k);
        }
    });

    // 2. คอลัมน์คำนำหน้า
    const pl = document.getElementById('pl');
    pl.innerHTML = selR ? '' : '<div class="text-center py-10 text-slate-300 text-[10px] italic">← เลือกหมวดก่อน</div>';
    if(selR) {
        state.hierarchy[selR].prefixes.forEach(p => {
            const score = state.prefixScores[p] || 0;
            if (editingItem.type === 'pre' && editingItem.value === p) {
                pl.innerHTML += inlineEditHTML('pre', p, score);
            } else {
                pl.innerHTML += itemHTML('pre', p, `delData('pre','${p}')`, `selectPre('${p}')`, score, selP === p);
            }
        });
    }

    // 3. คอลัมน์สร้อยพระนาม
    const sl = document.getElementById('sl');
    sl.innerHTML = (selR && selP) ? '' : '<div class="text-center py-10 text-slate-300 text-[10px] italic">← เลือกคำนำหน้าก่อน</div>';
    if(selR && selP) {
        (state.hierarchy[selR].suffixes[selP] || []).forEach(s => {
            const score = state.suffixScores[s] || 0;
            if (editingItem.type === 'suf' && editingItem.value === s) {
                sl.innerHTML += inlineEditHTML('suf', s, score);
            } else {
                sl.innerHTML += itemHTML('suf', s, `delData('suf','${s}')`, "", score);
            }
        });
    }

    // 4. คอลัมน์นามแผ่นดิน
    const gl = document.getElementById('reignl'); gl.innerHTML = '';
    state.reignNames.forEach(n => { 
        if (editingItem.type === 'reign' && editingItem.value === n) {
            gl.innerHTML += inlineEditHTML('reign', n);
        } else {
            gl.innerHTML += itemHTML('reign', n, `delData('reign','${n}')`); 
        }
    });
}

// สร้าง HTML สำหรับโหมดแก้ไขในแถว (ตามรูปภาพที่คุณวิทยาแนบมา)
function inlineEditHTML(type, value, score = 0) {
    const showScore = (type === 'pre' || type === 'suf');
    return `
        <div class="p-3 bg-white rounded-2xl border-2 border-blue-100 shadow-sm mb-2 space-y-2 animate-fade-in">
            <div class="flex gap-2">
                <input id="inline_edit_name" class="flex-1 px-3 py-2 rounded-xl border-2 border-sky-400 outline-none text-sm font-bold" value="${value}">
                ${showScore ? `<input id="inline_edit_score" type="number" class="w-16 px-1 py-2 rounded-xl border-2 border-slate-100 outline-none text-sm text-center" value="${score}">` : ''}
            </div>
            <div class="flex gap-2">
                <button onclick="saveInlineEdit('${type}', '${value}')" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-xl text-[11px] font-bold transition flex items-center justify-center gap-2">
                    <i class="fa-solid fa-save"></i> บันทึกการแก้ไข
                </button>
                <button onclick="cancelInlineEdit()" class="px-4 bg-slate-400 hover:bg-slate-500 text-white py-2 rounded-xl text-[11px] font-bold transition">
                    ยกเลิก
                </button>
            </div>
        </div>`;
}

function itemHTML(type, value, deleteFn, clickFn = "", score = null, isSelected = false) {
    const scoreBadge = score !== null ? `<div class="text-[10px] text-slate-400 font-mono">คะแนน: ${score}</div>` : '';
    const activeClass = isSelected ? 'bg-indigo-50 border-indigo-200' : 'bg-white border-slate-50';
    return `
        <li data-id="${value}" data-type="${type}" class="flex justify-between items-center p-3 border rounded-2xl transition group ${activeClass} mb-1" onclick="${clickFn}">
            <div class="flex items-center gap-3 overflow-hidden">
                <i class="fa-solid fa-grip-vertical text-slate-200 text-xs shrink-0 cursor-grab"></i>
                <div class="truncate">
                    <div class="text-sm font-bold ${isSelected ? 'text-indigo-600' : 'text-slate-700'} truncate">${value}</div>
                    ${scoreBadge}
                </div>
            </div>
            <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition">
                <button onclick="event.stopPropagation(); editData('${type}', '${value}')" class="p-1.5 text-blue-400 hover:bg-blue-50 rounded-lg">
                    <i class="fa-solid fa-pen-to-square text-xs"></i>
                </button>
                <button onclick="event.stopPropagation(); ${deleteFn}" class="p-1.5 text-red-300 hover:text-red-500">
                    <i class="fa-solid fa-trash-can text-xs"></i>
                </button>
            </div>
        </li>`;
}

function selectRel(k){ selR=k; selP=null; renderRM(); }
function selectPre(p){ selP=p; renderRM(); }

function addData(type) {
    if (type === 'rel') {
        const val = document.getElementById('nr').value.trim();
        if (!val) return showToast("กรุณากรอกชื่อความสัมพันธ์");
        state.hierarchy[val] = { prefixes: [], suffixes: {} };
        document.getElementById('nr').value = '';
    } 
    else if (type === 'pre') {
        if (!selR) return showToast("โปรดเลือกความสัมพันธ์ก่อน");
        const val = document.getElementById('np').value.trim();
        const score = parseInt(document.getElementById('np_score').value) || 0;
        if (!val) return showToast("กรุณากรอกคำนำหน้า");
        state.hierarchy[selR].prefixes.push(val);
        state.hierarchy[selR].suffixes[val] = [];
        state.prefixScores[val] = score;
        document.getElementById('np').value = ''; document.getElementById('np_score').value = '';
    } 
    else if (type === 'suf') {
        if (!selR || !selP) return showToast("โปรดเลือกคำนำหน้าก่อน");
        const val = document.getElementById('ns').value.trim();
        const score = parseInt(document.getElementById('ns_score').value) || 0;
        if (!val) return showToast("กรุณากรอกสร้อยพระนาม");
        state.hierarchy[selR].suffixes[selP].push(val);
        state.suffixScores[val] = score;
        document.getElementById('ns').value = ''; document.getElementById('ns_score').value = '0';
    } 
    else if (type === 'reign') {
        const val = document.getElementById('nreign').value.trim();
        if (!val) return showToast("กรุณากรอกนามแผ่นดิน");
        state.reignNames.push(val);
        document.getElementById('nreign').value = '';
    }
    saveState(); renderRM(); refreshAllDisplays(); showToast("เพิ่มข้อมูลเรียบร้อย ✨");
}

function delData(type, val) {
    if(!confirm('ยืนยันการลบ?')) return;
    if(type==='rel') delete state.hierarchy[val];
    else if(type==='pre') {
        state.hierarchy[selR].prefixes = state.hierarchy[selR].prefixes.filter(x=>x!==val);
        if(state.prefixScores) delete state.prefixScores[val];
    }
    else if(type==='suf') {
        state.hierarchy[selR].suffixes[selP] = state.hierarchy[selR].suffixes[selP].filter(x=>x!==val);
        if(state.suffixScores) delete state.suffixScores[val];
    }
    else if(type==='reign') state.reignNames = state.reignNames.filter(x=>x!==val);
    saveState(); renderRM(); refreshAllDisplays();
}

function initSortableColumns() {
    const config = {
        animation: 150, handle: '.fa-grip-vertical',
        onEnd: function(evt) {
            const type = evt.item.getAttribute('data-type');
            reorderState(type, evt.from);
        }
    };
    if (document.getElementById('rl')) new Sortable(document.getElementById('rl'), config);
    if (document.getElementById('pl')) new Sortable(document.getElementById('pl'), config);
    if (document.getElementById('sl')) new Sortable(document.getElementById('sl'), config);
    if (document.getElementById('reignl')) new Sortable(document.getElementById('reignl'), config);
}

function reorderState(type, parentEl) {
    const newOrder = Array.from(parentEl.children).map(li => li.getAttribute('data-id')).filter(id => id);
    if (type === 'rel') {
        const newHierarchy = {};
        newOrder.forEach(key => { if(state.hierarchy[key]) newHierarchy[key] = state.hierarchy[key]; });
        state.hierarchy = newHierarchy;
    } else if (type === 'pre' && selR) {
        state.hierarchy[selR].prefixes = newOrder;
    } else if (type === 'suf' && selR && selP) {
        state.hierarchy[selR].suffixes[selP] = newOrder;
    } else if (type === 'reign') {
        state.reignNames = newOrder;
    }
    saveState(); refreshAllDisplays();
}
    

    function selectRel(k){ selR=k; renderRM(); }
    function selectPre(p){ selP=p; renderRM(); }

    // ================= TABLE RENDER =================

    function renderTable() {
        const tbody = document.getElementById('tableBody');
        tbody.innerHTML = '';
        const q = document.getElementById('tableSearch').value.toLowerCase();
        const filterStatus = document.getElementById('tableFilterStatus').value;
        const btnReset = document.getElementById('btnResetPrecedence');
        if(btnReset) btnReset.classList.toggle('hidden', filterStatus !== 'precedence');

        let list = [...state.members];
        const activeMonarch = state.members.find(x => x.isMonarch && x.isAlive && !x.isExMonarch);

        if (filterStatus === 'alive') list = list.filter(m => m.isAlive);
        else if (filterStatus === 'dead') list = list.filter(m => !m.isAlive);
        else if (filterStatus === 'precedence') {
             list = list.filter(m => m.isAlive && calculatePojiamScore(m) > 0); 
        }
        
        if(q) list = list.filter(m => getFullDisplayTitle(m).toLowerCase().includes(q) || (m.nickname||'').toLowerCase().includes(q));

        if (filterStatus === 'precedence') {
            list.sort((a,b) => {
                const scoreA = calculatePojiamScore(a);
                const scoreB = calculatePojiamScore(b);
                return scoreB - scoreA;
            });
        } else {
            // Sort by Birth Year (oldest first) as a secondary sort for all other views
             list.sort((a,b) => {
                // MODIFICATION: Rely on isMonarch (historical) and isAlive/isExMonarch (active status)
                const aActive = a.isMonarch && a.isAlive && !a.isExMonarch;
                const bActive = b.isMonarch && b.isAlive && !b.isExMonarch;
                
                if(aActive && !bActive) return -1;
                if(!aActive && bActive) return 1;
                
                // If both are monarchs (historical or active), sort by reign start
                if(a.isMonarch && b.isMonarch) return (parseInt(a.reignStart)||0) - (parseInt(b.reignStart)||0);
                
                // Fallback sort by Birth Year
                const aYear = parseInt(a.birthYear) || Infinity;
                const bYear = parseInt(b.birthYear) || Infinity;
                if (aYear !== bYear) return aYear - bYear;
                
                return 0;
            });
        }

        if(list.length === 0) { tbody.innerHTML = `<tr><td colspan="6" class="text-center py-4 text-slate-400">ไม่พบข้อมูล</td></tr>`; return; }

        list.forEach((m, index) => {
            const dTerm = m.isAlive ? "" : getDeathTerm(m);
            const statusHTML = m.isAlive 
                ? '<span class="px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-600 text-xs font-bold">มีชีวิต</span>'
                : `<span class="px-2 py-0.5 rounded-full bg-slate-200 text-slate-500 text-xs font-bold">${dTerm}</span>`;
            
            const fName = state.members.find(x => x.id === m.fatherId)?.name || '-';
            const mName = state.members.find(x => x.id === m.motherId)?.name || '-';
            let fullName = getFullDisplayTitle(m);
            
            // --- NEW LABEL LOGIC ---
            let postNameTag = '';
            const reignLabel = m.globalReignNumber ? `รัชกาลที่ ${toThaiNumerals(m.globalReignNumber)}` : '';
            const isActiveMonarch = m.isMonarch && m.isAlive && !m.isExMonarch;
            const isCurrentMonarchConsort = m.isQueenConsort && activeMonarch && (activeMonarch.spouseIds||[]).includes(m.id);
            const isHeirApparent = m.isHeir && parseInt(m.heirOrder) === 1;

            if (filterStatus === 'precedence') {
                if (isActiveMonarch) {
                    // Current Monarch in Precedence view (Yellow, Glowing)
                    postNameTag = `<span class="monarch-tag-table">พระมหากษัตริย์ ${reignLabel}</span>`;
                } else if (isCurrentMonarchConsort) {
                    // Current Queen Consort in Precedence view (Pink, Glowing)
                    postNameTag = `<span class="queen-consort-tag-table">พระมหาราชินีคู่บัลลังก์</span>`;
                } else if (isHeirApparent) {
                    // Heir Apparent Order 1 in Precedence view (Red, Glowing)
                    postNameTag = `<span class="heir-tag-table">พระมหารัชทายาท</span>`;
                }
            } 
            
            // Apply Deceased Monarch Tag for 'all' and 'dead' views
            if ((filterStatus === 'all' || filterStatus === 'dead') && !m.isAlive && m.isMonarch && m.globalReignNumber) {
                 // Deceased Monarch in All or Dead view (Yellow, Glowing)
                 postNameTag = `<span class="monarch-tag-table">${reignLabel}</span>`;
            }
            
            // Default active monarch label for 'all'/'alive' view if no special tag
            if (isActiveMonarch && !postNameTag) { 
                const reignLabelDefault = getGlobalReignLabel(m);
                // Use the standard, non-glowing badge for non-precedence views
                fullName += ` <span class="text-xs text-amber-600 font-bold bg-amber-50 px-1 rounded border border-amber-200 ml-1">${reignLabelDefault}</span>`; 
            }
            
            if (postNameTag) {
                fullName += postNameTag;
            }

            const nn = getNicknameWithPrefix(m);
            const nnHTML = nn !== '-' ? `<div class="text-xs text-slate-400 font-normal mt-0.5">(${nn})</div>` : '';

            let rankIndex = '';
            if (filterStatus === 'precedence') {
                const pojiamScore = calculatePojiamScore(m);
                if (pojiamScore > 0) {
                    const rankNum = index + 1;
                    
                    let isGoldRank = false;
                    
                    if (isActiveMonarch || isCurrentMonarchConsort || isHeirApparent) isGoldRank = true;
                    else if (m.isExMonarch && m.isAlive) { // Highlight Ex-Monarch
                        isGoldRank = true;
                    }

                    if (isGoldRank) {
                        rankIndex = `<div class="inline-flex items-center justify-center w-6 h-6 mr-2 rounded-full bg-amber-100 text-amber-600 font-bold text-xs shadow-sm border border-amber-200">#${rankNum}</div>`;
                    } else {
                        rankIndex = `<span class="inline-block w-6 text-center font-mono text-xs text-slate-400 mr-2">#${rankNum}</span>`;
                    }
                } 
            }

            const row = document.createElement('tr');
            row.className = "data-row transition border-b border-slate-100 hover:bg-slate-50";
            row.innerHTML = `
                <td class="text-center py-2"><img src="${m.image || (m.gender==='M'?DEFAULT_IMG_MALE:DEFAULT_IMG_FEMALE)}" class="w-8 h-8 rounded-full mx-auto object-cover border"></td>
                <td class="py-2 text-sm font-bold text-slate-700 cursor-pointer hover:text-blue-500" onclick="showDetail('${m.id}')">
                    ${rankIndex}${fullName}${nnHTML}
                </td>
                <td class="py-2">${statusHTML}</td>
                <td class="py-2"><span class="text-xs text-slate-500">${fName} / ${mName}</span></td>
                <td class="text-center py-2">
                    <button onclick="editPersonDirect('${m.id}')" class="text-slate-400 hover:text-blue-500"><i class="fa-solid fa-pen-to-square"></i></button>
                </td>
            `;
            tbody.appendChild(row);
        });
    }

    function editPersonDirect(id) { const m = state.members.find(x => x.id === id); if(m) openModal(m, true); }

    // ================= MONARCH & MODAL HELPERS (RESTORED) =================

    function renderMonarchBanner() {
        try {
            const activeMonarch = state.members.find(m => m.isMonarch && m.isAlive && !m.isExMonarch);
            const banner = document.getElementById('monarchBanner');
            const vacant = document.getElementById('monarchVacant');
            if(activeMonarch) {
                banner.classList.remove('hidden'); banner.classList.add('flex'); vacant.classList.add('hidden'); vacant.classList.remove('flex');
                document.getElementById('monarchImg').src = activeMonarch.image || (activeMonarch.gender==='M'?DEFAULT_IMG_MALE:DEFAULT_IMG_FEMALE);
                document.getElementById('monarchName').innerText = getFullDisplayTitle(activeMonarch) + " " + getGlobalReignLabel(activeMonarch);
            } else {
                banner.classList.add('hidden'); banner.classList.remove('flex');
                if(state.members.length > 0) { vacant.classList.remove('hidden'); vacant.classList.add('flex'); } 
                else { vacant.classList.add('hidden'); vacant.classList.remove('flex'); }
            }
        } catch(e) { console.error("Banner Render Error:", e); }
    }

    // ================= MONARCH & QUEEN CONSORT HELPERS (FIXED ORDERING) =================

    function checkQueenConsortEligible() { 
        const g = document.querySelector('input[name="gender"]:checked').value; 
        const r = document.getElementById('p_relationship').value; 
        const ok = g === 'F' && (r === 'พระภรรยาเจ้า' || r === 'พระชายา' || (r||'').includes('บาทบริจาริกา') || r === 'หม่อม'); 
        document.getElementById('queenConsortOption').classList.toggle('hidden', !ok); 
    }

    function updateQueenConsortSelector(d) {
        const selDiv = document.getElementById('maleMonarchQueenSelect');
        const sel = document.getElementById('p_queenSelectForKing');
        const genderEl = document.querySelector('input[name="gender"]:checked');
        const genderVal = genderEl ? genderEl.value : 'M';
        const isKing = document.getElementById('p_isMonarch').checked && genderVal === 'M';
        if(isKing) {
            selDiv.classList.remove('hidden');
            sel.innerHTML = '<option value="">-- เลือก --</option>';
            const spouseIds = [];
            document.getElementById('p_spouseList').querySelectorAll('li').forEach(li => spouseIds.push(li.dataset.id));
            let currentQueenId = null;
            spouseIds.forEach(sid => {
                const s = state.members.find(m => m.id === sid);
                const isConsort = s && s.gender === 'F' && (s.relationship === 'พระภรรยาเจ้า' || s.relationship === 'พระชายา' || s.relationship === 'หม่อม' || (s.relationship||'').includes('บาทบริจาริกา'));
                if(isConsort) {
                    const op = document.createElement('option');
                    op.value = s.id; op.innerText = s.name;
                    sel.appendChild(op);
                    if(s.isQueenConsort) currentQueenId = s.id;
                }
            });
            if(currentQueenId) sel.value = currentQueenId;
        } else { selDiv.classList.add('hidden'); }
    }

    function toggleMonarch() { 
        const isM = document.getElementById('p_isMonarch').checked; 
        document.getElementById('monarchPanel').classList.toggle('hidden', !isM); 
        checkQueenConsortEligible(); updateQueenConsortSelector(); 
        if(isM && document.getElementById('p_isEditMode').value !== 'true') {
             const monarchs = state.members.filter(x => x.isMonarch);
             const maxGlobal = Math.max(0, ...monarchs.map(x => parseInt(x.globalReignNumber||0)));
             document.getElementById('p_globalReignNumber').value = maxGlobal + 1;
        }
    }
    // ================= END MONARCH HELPERS =================


    function openAppointModal() {
        const s = document.getElementById('appointSelectModal'); s.innerHTML = '';
        const eligible = state.members.filter(m => m.isAlive && !m.royalRank.includes('หม่อมเจ้า') && !m.royalRank.includes('สามัญชน') && !(m.relationship||'').includes('บาทบริจาริกา'));
        if(eligible.length === 0) { showToast("ไม่พบผู้มีสิทธิ์สืบราชสมบัติ"); return; }
        eligible.forEach(m => { const op = document.createElement('option'); op.value = m.id; op.innerText = `${m.royalRank} ${m.name}`; s.appendChild(op); });
        document.getElementById('appointModal').classList.add('active');
    }

    let tempAppointId = null;
    function appointFromModal() {
        const id = document.getElementById('appointSelectModal').value;
        closeModal('appointModal');
        openReignNameSelectionModal(id);
    }

    function openReignNameSelectionModal(id) {
        tempAppointId = id;
        const s = document.getElementById('reignSelectionInput');
        s.innerHTML = '';
        state.reignNames.forEach(n => {
            const op = document.createElement('option');
            op.value = n; op.innerText = n;
            s.appendChild(op);
        });
        document.getElementById('reignSelectionModal').classList.add('active');
    }

    function confirmReignSelection() {
        const rName = document.getElementById('reignSelectionInput').value;
        if(tempAppointId && rName) {
            performSuccession(tempAppointId, rName);
            closeModal('reignSelectionModal');
        }
    }

    function performSuccession(newMonarchId, reignNameBase) {
        const m = state.members.find(x => x.id === newMonarchId);
        if(m) { 
            // 1. Demote/Clear former Monarchs/Heirs
            state.members.forEach(p => {
                if (p.isHeir) {
                    p.isHeir = false;
                    p.heirOrder = null;
                }
                
                // If the person was the active monarch (not the new one), mark them as ex-monarch.
                if (p.id !== newMonarchId && p.isMonarch) {
                    if (!p.reignEnd) p.reignEnd = new Date().getFullYear() + 543;
                    // Keep isMonarch: true (as requested).
                    // Set isExMonarch based on whether they are alive or recently active.
                    if (p.isAlive) {
                        p.isExMonarch = true; // Still alive, now a former monarch.
                    } else {
                         p.isExMonarch = false; // Deceased historical monarch.
                    }
                }
            });
            
            // 2. Set new Monarch properties
            m.relationship = "พระมหากษัตริย์";
            if(state.hierarchy["พระมหากษัตริย์"]) {
                const defaults = state.hierarchy["พระมหากษัตริย์"];
                if(defaults.prefixes && defaults.prefixes.length > 0) {
                    m.titlePrefix = defaults.prefixes[0];
                    if(defaults.suffixes && defaults.suffixes[m.titlePrefix] && defaults.suffixes[m.titlePrefix].length > 0) {
                        m.titleSuffix = defaults.suffixes[m.titlePrefix][0];
                    }
                }
            }
            m.isMonarch = true; 
            m.isExMonarch = false; // Ensure new monarch is not marked as ex-monarch
            m.isHeir = false; 
            m.heirOrder = null;
            m.reignStart = new Date().getFullYear() + 543; 
            m.reignEnd = ''; // Clear end date
            m.useReignName = true;
            m.reignNameBase = reignNameBase;
            
            // Recalculate global reign number based on all historical monarchs
            const monarchs = state.members.filter(x => x.isMonarch);
            const maxGlobal = Math.max(0, ...monarchs.map(x => parseInt(x.globalReignNumber||0)));
            if (!m.globalReignNumber) m.globalReignNumber = maxGlobal + 1;
            
            // RULE: If established as King, clear Krom rank (ล้างกรมออก)
            m.kromRank = '';
            m.kromTitle = '';

            // NEW: Clear monarchSpouseContext for the new King's current spouses (they are current consorts, not former's)
            (m.spouseIds || []).forEach(sid => {
                const spouse = state.members.find(s => s.id === sid);
                if (spouse) {
                    spouse.monarchSpouseContext = null;
                }
            });
            
            // 3. Process Spouses (Promotion) - This is where the user's rule is implemented
            const monarch = state.members.find(x => x.id === newMonarchId);
            (monarch.spouseIds || []).forEach(sid => {
                const spouse = state.members.find(s => s.id === sid);
                if (spouse && spouse.isAlive) {

                    const isFormerPrinceConsort = spouse.relationship && 
                                                 !spouse.relationship.includes('พระมหากษัตริย์') && 
                                                 !spouse.relationship.includes('พระราชินี') &&
                                                 spouse.relationship !== 'พระภรรยาเจ้า' &&
                                                 !spouse.relationship.includes('บาทบริจาริกา');
                    
                    if (isFormerPrinceConsort) {
                        const hasChildren = state.members.some(c => c.fatherId === monarch.id && c.motherId === spouse.id);
                        
                        if (spouse.relationship === 'พระชายา') {
                            spouse.relationship = 'พระภรรยาเจ้า'; 
                            spouse.titlePrefix = 'พระราชชายา';
                            
                            if (!spouse.royalRank || spouse.royalRank === 'สามัญชน' || spouse.royalRank === 'หม่อมเจ้า' || spouse.royalRank === 'หม่อมราชวงศ์' || spouse.royalRank === 'หม่อมหลวง') {
                                 spouse.royalRank = 'พระองค์เจ้า (ชั้นเอก)';
                                 showToast(`เลื่อนสถานะคู่สมรส: ${spouse.name} จาก พระชายา เป็น พระราชชายา (พระภรรยาเจ้า) และได้รับยศ ${spouse.royalRank.split(' ')[0]}`);
                            } else {
                                showToast(`เลื่อนสถานะคู่สมรส: ${spouse.name} จาก พระชายา เป็น พระราชชายา (พระภรรยาเจ้า)`);
                            }
                        } 
                        else if (spouse.relationship === 'หม่อม' || (spouse.royalRank || '').includes('สามัญชน')) {
                            spouse.relationship = 'บาทบริจาริกา';
                            
                            if (hasChildren) {
                                spouse.titlePrefix = 'เจ้าจอมมารดา'; 
                                showToast(`เลื่อนสถานะคู่สมรส: ${spouse.name} จาก หม่อม เป็น เจ้าจอมมารดา (บาทบริจาริกา)`);
                            } else {
                                spouse.titlePrefix = 'เจ้าจอม'; 
                                showToast(`เลื่อนสถานะคู่สมรส: ${spouse.name} จาก หม่อม เป็น เจ้าจอม (บาทบริจาริกา)`);
                            }
                        }
                        
                        spouse.isQueenConsort = false; 
                    }
                }
            });

            // 4. CLASSIFICATION: Process all other members based on the new Monarch
            const newMonarch = m; 
            const newMonarchFatherId = newMonarch.fatherId;
            const newMonarchMotherId = newMonarch.motherId;
            const monarchBirthYear = parseInt(newMonarch.birthYear) || Infinity; 

            state.members.forEach(p => {
                if (p.id === newMonarchId || p.isMonarch || p.isExMonarch || newMonarch.spouseIds.includes(p.id)) return;

                const isFormerConsortOfMonarch = (p.relationship === 'พระภรรยาเจ้า' || p.relationship.includes('บาทบริจาริกา'));
                if (isFormerConsortOfMonarch) {
                    return; 
                }

                const rank = p.royalRank || 'สามัญชน';
                const isRoyalRank = rank.includes('เจ้าฟ้า') || rank.includes('พระองค์เจ้า') || rank.includes('หม่อมเจ้า') || rank.includes('เจ้าประเทศราช');
                if (!isRoyalRank) return;

                let newRelationship = null;
                let newPrefix = null;

                // --- 4.A. Direct Children of the Monarch (Highest Rank, already handled implicitly by calculateChildRank) ---
                const { isChild, isGrandchild } = isDirectDescendant(newMonarchId, p.id);
                if (isChild) {
                    const otherParentId = (p.fatherId === newMonarchId) ? p.motherId : p.fatherId;
                    const calculated = calculateChildRank(newMonarchId, otherParentId, p.gender);
                    p.royalRank = calculated.royalRank;
                    p.titlePrefix = calculated.titlePrefix;
                    p.relationship = calculated.relationship;
                    p.royalSurname = calculated.royalSurname; // Update surname
                    p.surname = calculated.surname;
                    return; 
                }
                
                // --- 4.B. Full Siblings (พระเจ้าพี่น้องร่วมพระมารดา) ---
                const isFullSibling = (p.fatherId === newMonarchFatherId && p.motherId === newMonarchMotherId && p.fatherId && p.motherId);
                
                if (isFullSibling) {
                    
                    let isOlder = false;
                    const personBirthYear = parseInt(p.birthYear) || Infinity;

                    if (personBirthYear !== Infinity && monarchBirthYear !== Infinity) {
                        isOlder = personBirthYear < monarchBirthYear;
                    } else {
                        isOlder = p.id.localeCompare(newMonarchId) < 0; 
                    }

                    newRelationship = "พระเจ้าพี่น้องร่วมพระมารดา"; 

                    if (p.gender === 'M') {
                        const prefixBase = rank.includes('เจ้าฟ้า') ? `สมเด็จพระเจ้า` : `พระเจ้า`;
                        const brotherSuffix = isOlder ? 'พี่ยาเธอ' : 'น้องยาเธอ';
                        newPrefix = `${prefixBase}${brotherSuffix}`;
                    } else { // Female
                        const prefixBase = rank.includes('เจ้าฟ้า') ? `สมเด็จพระเจ้า` : `พระเจ้า`;
                        const sisterSuffix = isOlder ? 'พี่นางเธอ' : 'น้องนางเธอ';
                        newPrefix = `${prefixBase}${sisterSuffix}`;
                    }
                } 
                
                // --- 4.C. Direct Grandchildren (ลูกของลูก) (พระเจ้าหลานเธอ) ---
                else if (isGrandchild) {
                    newRelationship = "พระเจ้าหลานเธอ";
                    if (rank.includes('เจ้าฟ้า')) {
                        newPrefix = 'สมเด็จพระเจ้าหลานเธอ';
                    } else if (rank.includes('พระองค์เจ้า')) {
                        newPrefix = 'พระเจ้าหลานเธอ';
                    }
                } 
                
                // --- 4.D. Close Relatives (Half Siblings / Old Monarch's Children) (พระบรมวงศ์) ---
                else {
                    const isHalfSibling = (p.fatherId === newMonarchFatherId && p.fatherId) || 
                                          (p.motherId === newMonarchMotherId && p.motherId);
                                        
                    const isChildOfFormerMonarch = (p.fatherId && state.members.find(x => x.id === p.fatherId)?.isMonarch) ||
                                                    (p.motherId && state.members.find(x => x.id === p.motherId)?.isMonarch);

                    if (isHalfSibling || isChildOfFormerMonarch) {
                        newRelationship = "พระบรมวงศ์";
                        if (rank.includes('เจ้าฟ้า')) {
                            newPrefix = 'สมเด็จพระเจ้าบรมวงศ์เธอ';
                        } else if (rank.includes('พระองค์เจ้า')) {
                            newPrefix = 'พระเจ้าบรมวงศ์เธอ';
                        }
                    } 
                    
                    // --- 4.E. Distant Relatives (พระอนุวงศ์) ---
                    else {
                         newRelationship = "พระอนุวงศ์";
                         if (rank.includes('เจ้าฟ้า')) {
                             newPrefix = 'สมเด็จพระเจ้าวรวงศ์เธอ';
                         } else if (rank.includes('พระองค์เจ้า')) {
                             newPrefix = 'พระเจ้าวรวงศ์เธอ';
                         }
                    }
                }

                // --- 4.F. Apply Changes ---
                if (newRelationship) {
                     const oldRelationship = p.relationship;
                     p.relationship = newRelationship;
                     p.titlePrefix = newPrefix || '';
                     if (newRelationship !== oldRelationship) {
                          showToast(`อัปเดตสถานะ: ${p.name} เป็น ${newRelationship.replace('พระเจ้าพี่น้องร่วมพระมารดา', newPrefix)} ${getDisplayRank(p.royalRank)}`);
                     }
                }
            });


            saveState(); updateApp(); showFantasyPopup(m); 
        }
    }

    function handleMonarchDeath(monarch) {
        if(monarch.spouseIds && monarch.spouseIds.length > 0) {
            const reignNum = getGlobalReignLabel(monarch); 
            monarch.spouseIds.forEach(sid => {
                const sp = state.members.find(x => x.id === sid);
                if(sp && sp.isAlive) {
                    const rel = sp.relationship || '';
                    if (rel === 'พระภรรยาเจ้า' || rel.includes('บาทบริจาริกา') || sp.isQueenConsort) {
                        sp.isQueenConsort = false;
                        sp.monarchSpouseContext = `ใน${reignNum}`;
                        showToast(`ตั้งพระนาม/สร้อยท้าย: ${sp.name} ด้วย ${sp.monarchSpouseContext}`);
                    } else {
                         sp.monarchSpouseContext = null;
                    }
                }
            });
        }
        
        // OLD: monarch.isMonarch = false; // REMOVED per user request
        monarch.isExMonarch = false; // Deceased monarch is not a *living* ex-monarch
        monarch.reignEnd = new Date().getFullYear() + 543;
        
        const heirs = state.members.filter(m => m.isHeir && m.isAlive).sort((a,b) => (a.heirOrder||99) - (b.heirOrder||99));
        if(heirs.length > 0 && parseInt(heirs[0].heirOrder) === 1) { // Only Heir Apparent Order 1 succeeds automatically
            const successor = heirs[0];
            showToast(`กำลังสถาปนา ${successor.name} ขึ้นครองราชย์...`);
            setTimeout(() => {
                openReignNameSelectionModal(successor.id);
                // Demote other heirs
                state.members.filter(m => m.isHeir && m.isAlive && m.id !== successor.id).forEach(h => { 
                    if(h.heirOrder > 1) h.heirOrder--; 
                });
                saveState();
            }, 2000);
        } else {
             showToast(`บัลลังก์ว่างลง! ไม่พบรัชทายาทลำดับที่ ๑`);
             saveState();
        }
    }

    function handleHeirDeath(p) {
        if (!p.heirOrder) return;
        const deadOrder = parseInt(p.heirOrder);
        p.isHeir = false; // Must explicitly mark as not heir
        p.heirOrder = null; 
        state.members.forEach(m => {
            if (m.isAlive && m.isHeir && m.heirOrder && parseInt(m.heirOrder) > deadOrder) {
                m.heirOrder = parseInt(m.heirOrder) - 1;
            }
        });
    }

    function showFantasyPopup(monarch) {
        const modal = document.getElementById('fantasyModal');
        document.getElementById('fan_name').innerText = getFullDisplayTitle(monarch);
        document.getElementById('fan_rama').innerText = getGlobalReignLabel(monarch);
        document.getElementById('fan_img').src = monarch.image || (monarch.gender==='M'?DEFAULT_IMG_MALE:DEFAULT_IMG_FEMALE);
        document.getElementById('fan_dynasty').innerText = state.dynastyName || '-';
        document.getElementById('fan_kingdom').innerText = state.kingdomName || '-';
        const pc = document.getElementById('fantasyParticles'); pc.innerHTML = '';
        for(let i=0; i<30; i++) {
            const p = document.createElement('div'); p.className = 'particle';
            p.style.left = Math.random()*100 + '%'; p.style.width = Math.random()*6 + 2 + 'px'; p.style.height = p.style.width; p.style.animationDelay = Math.random()*2 + 's';
            p.style.background = Math.random() > 0.5 ? '#ffd700' : '#fff'; pc.appendChild(p);
        }
        modal.classList.add('active');
    }
    
    // ================= NEW: ABDICATION LOGIC =================

    function abdicateCurrent() {
        if(!confirm('ยืนยันการสละราชสมบัติ? การดำเนินการนี้จะส่งผลให้มีการสถาปนากษัตริย์องค์ใหม่ทันที (หากมีรัชทายาทลำดับที่ ๑)')) return;
        
        const monarch = state.members.find(m=>m.id===window.curPID); 
        if (!monarch || !monarch.isMonarch || monarch.isExMonarch) {
            showToast("บุคคลนี้ไม่ใช่พระมหากษัตริย์ที่กำลังครองราชย์");
            return;
        }
        
        const currentReignNum = monarch.globalReignNumber;
        
        // 1. Demote current Monarch
        monarch.isExMonarch = true;
        // OLD: monarch.isMonarch = false; // REMOVED per user request
        monarch.reignEnd = new Date().getFullYear() + 543;
        
        // 2. Process current Monarch's spouse context (like death)
        if(monarch.spouseIds && monarch.spouseIds.length > 0) {
            const reignLabel = `รัชกาลที่ ${toThaiNumerals(currentReignNum)}`; 
            monarch.spouseIds.forEach(sid => {
                const sp = state.members.find(x => x.id === sid);
                if(sp && sp.isAlive) {
                    const rel = sp.relationship || '';
                    if (rel === 'พระภรรยาเจ้า' || rel.includes('บาทบริจาริกา') || sp.isQueenConsort) {
                        // The Queen Consort loses the title (isQueenConsort=false) but gains the context suffix
                        sp.isQueenConsort = false;
                        sp.monarchSpouseContext = `ใน${reignLabel}`;
                        showToast(`ตั้งสร้อยท้าย: ${sp.name} ด้วย ${sp.monarchSpouseContext}`);
                    }
                }
            });
        }
        
        // 3. Find and appoint Heir Apparent (Order 1)
        const heirs = state.members.filter(m => m.isHeir && m.isAlive)
                                   .sort((a,b) => (a.heirOrder||99) - (b.heirOrder||99));
        
        // Set former monarch's flags for persistence
        // monarch.isMonarch remains true
        monarch.isHeir = false;
        monarch.heirOrder = null;
        
        saveState(); // Save current monarch's new state before succession is triggered

        closeModal('detailModal'); 
        
        if(heirs.length > 0 && parseInt(heirs[0].heirOrder) === 1) {
            const successor = heirs[0];
            showToast(`กำลังสถาปนา ${successor.name} ขึ้นครองราชย์ (สืบราชสันตติวงศ์อัตโนมัติ)...`);
            setTimeout(() => {
                // Demote other heirs after the new one is chosen
                state.members.filter(m => m.isHeir && m.isAlive && m.id !== successor.id).forEach(h => { 
                    if(h.heirOrder > 1) h.heirOrder--; 
                });
                openReignNameSelectionModal(successor.id);
            }, 500);
        } else {
            showToast(`บัลลังก์ว่างลง! ไม่พบรัชทายาทลำดับที่ ๑`);
            // If no successor, we just save and update to show the vacant throne
            saveState();
            refreshAllDisplays(); 
        }
    }

    // ================= END ABDICATION LOGIC =================
    
    // ================= NEW SPOUSE SELECTION MODAL LOGIC =================
    
    // 1. New function to open the selection modal (replaces the old openAddSpouseModal(id))
    function openSpouseSelectionModal(id) {
        closeModal('detailModal');
        
        targetOriginIdForSpouse = id;
        const originPerson = state.members.find(m => m.id === id);
        
        // Prepare list of eligible spouses (not self, not current spouse)
        const currentSpouseIds = originPerson.spouseIds || [];
        const eligible = state.members.filter(m => 
            m.id !== id && 
            !currentSpouseIds.includes(m.id) &&
            m.isAlive // Only suggest living people
        );

        const dl = document.getElementById('eligibleSpouseList');
        dl.innerHTML = '';
        eligible.forEach(m => {
            const op = document.createElement('option');
            // Format: ID : Full Name
            op.value = `${m.id} : ${getFullDisplayTitle(m)}`; 
            dl.appendChild(op);
        });

        // Reset inputs
        document.getElementById('existingSpouseSearch').value = '';
        document.getElementById('selectedExistingSpouseId').value = '';

        document.getElementById('spouseSelectionModal').classList.add('active');
    }

    // 2. Validate input against datalist options
    function validateExistingSpouseInput() {
        const input = document.getElementById('existingSpouseSearch').value.trim();
        const hiddenId = document.getElementById('selectedExistingSpouseId');
        
        hiddenId.value = ''; // Reset ID

        // Try matching the whole string (ID : Name)
        const eligibleOptions = document.getElementById('eligibleSpouseList').options;
        for (let i = 0; i < eligibleOptions.length; i++) {
            if (eligibleOptions[i].value === input) {
                // Extract ID from "ID : Name" format
                const id = input.split(' : ')[0].trim();
                hiddenId.value = id;
                return;
            }
        }

        // Try matching just the ID or Name
        const parts = input.split(' : ');
        const searchVal = parts.length > 1 ? parts[0].trim() : input; // If split, use ID part, otherwise use full input
        
        const exists = state.members.find(m => m.id === searchVal || m.name === searchVal);
        
        if (exists) {
            hiddenId.value = exists.id;
            // Optionally, update the input value to the full format for clarity
            document.getElementById('existingSpouseSearch').value = `${exists.id} : ${getFullDisplayTitle(exists)}`;
        }
    }

    // 3. Link the selected existing spouse
    function confirmLinkExistingSpouse() {
        const spouseId = document.getElementById('selectedExistingSpouseId').value;
        if (!spouseId || !targetOriginIdForSpouse) {
            showToast("กรุณาเลือกบุคคลจากรายชื่อที่ถูกต้อง");
            return;
        }

        const p1 = state.members.find(m => m.id === targetOriginIdForSpouse);
        const p2 = state.members.find(m => m.id === spouseId);

        if (p1 && p2) {
            // Add ID to spouseIds of both parties
            if (!p1.spouseIds) p1.spouseIds = [];
            if (!p2.spouseIds) p2.spouseIds = [];

            if (!p1.spouseIds.includes(p2.id)) p1.spouseIds.push(p2.id);
            if (!p2.spouseIds.includes(p1.id)) p2.spouseIds.push(p1.id);

            // Re-run checkConsortMotherhood if p1 or p2 is a female consort and now has children
            [p1, p2].forEach(p => {
                if (p.gender === 'F' && (p.relationship||'').includes('บาทบริจาริกา')) {
                    checkConsortMotherhood(p); // This function mutates the state (updates titlePrefix)
                }
            });
            
            saveState();
            closeModal('spouseSelectionModal');
            showToast(`เชื่อมโยง ${p1.name} และ ${p2.name} เรียบร้อยแล้ว`);
            refreshAllDisplays();
            
            // Open detail view for confirmation
            showDetail(targetOriginIdForSpouse);
        } else {
             showToast("ไม่พบบุคคลที่ต้องการเชื่อมโยง");
        }
    }

    // 4. Proceed to the normal Add New Person form
    function proceedToNewSpouse() {
        closeModal('spouseSelectionModal');
        
        const m = state.members.find(x => x.id === targetOriginIdForSpouse);
        
        if (m) {
            // If the original person has spouses, we should only suggest the opposite gender
            const recommendedGender = m.gender === 'M' ? 'F' : 'M';
            
            // Pass the original person's ID as the spouse in the initial data
            openModal({ 
                spouseIds: [m.id], 
                gender: recommendedGender,
                // If the original person is a King/Prince, the new spouse should default to a consort/wife rank
                relationship: m.isMonarch ? 'พระภรรยาเจ้า' : (m.royalRank.includes('เจ้าฟ้า') || m.royalRank.includes('พระองค์เจ้า') ? 'พระชายา' : 'หม่อม') 
            }, false, `คู่สมรสของ ${m.name}`);
        } else {
             showToast("เกิดข้อผิดพลาด: ไม่พบบุคคลต้นทาง");
        }
    }

    // 5. Update showDetail to call the new function
    function showDetail(id) {
        window.curPID = id;
        const m = state.members.find(x => x.id === id);
        if(!m) return;
        
        // Find and replace the onclick handler for the "เพิ่มคู่สมรส" button
        const addSpouseButton = document.querySelector('#detailModal button[onclick^="openSpouseSelectionModal"]');
        if (addSpouseButton) {
             addSpouseButton.onclick = () => openSpouseSelectionModal(window.curPID);
        } else {
             // Fallback/Safety Check: Ensure the button uses the correct function in the HTML
        }
        
        // Control Abdicate Button
        const btnAbdicate = document.getElementById('btnAbdicate');
        const btnDeath = document.getElementById('btnDeath');
        const activeMonarch = state.members.find(p => p.isMonarch && p.isAlive && !p.isExMonarch);

        // MODIFICATION (Rule 1 & 2): Show 4 buttons for active monarch
        const isActiveMonarch = m.isMonarch && m.isAlive && !m.isExMonarch && m.id === activeMonarch?.id;

        if (isActiveMonarch) {
            btnAbdicate.classList.remove('hidden');
            btnDeath.classList.remove('hidden'); // <-- Keep Death button visible
        } else {
            btnAbdicate.classList.add('hidden');
            btnDeath.classList.remove('hidden');
        }
        
        document.getElementById('d_img').src = m.image || (m.gender==='M'?DEFAULT_IMG_MALE:DEFAULT_IMG_FEMALE);
        document.getElementById('d_name').innerText = getFullDisplayTitle(m);
        document.getElementById('d_id').innerText = m.id;
        const kromEl = document.getElementById('d_krom');
        
        const isHighRoyalTitle = isActiveMonarch || (m.isHeir && parseInt(m.heirOrder) === 1);
        if(m.kromRank && m.kromTitle && !isHighRoyalTitle) { 
            kromEl.innerText = `${m.kromRank}${m.kromTitle}`; 
            kromEl.classList.remove('hidden'); 
        } else { 
            kromEl.classList.add('hidden'); 
        }
        
        const badgesContainer = document.getElementById('d_badges'); badgesContainer.innerHTML = '';
        
        if (m.isMonarch && m.isExMonarch && m.isAlive) { // NEW: Ex-Monarch Badge
             const reignNum = m.globalReignNumber ? `ร. ${toThaiNumerals(m.globalReignNumber)}` : '';
             const b = document.createElement('div');
             b.className = "bg-purple-100 text-purple-800 border border-purple-300 px-3 py-1 rounded-full text-xs font-bold";
             b.innerText = `อดีตพระมหากษัตริย์ ${reignNum}`; badgesContainer.appendChild(b);
        } else if (m.isMonarch && m.useReignName && m.reignNameBase && !m.isExMonarch) {
            let reignTxt = m.reignNameBase;
            const autoNum = getReignNameRank(m);
            if(autoNum) reignTxt += `ที่ ${toThaiNumerals(autoNum)}`;
            const b = document.createElement('div');
            b.className = "bg-yellow-100 text-yellow-800 border border-yellow-300 px-3 py-1 rounded-full text-xs font-bold";
            b.innerText = reignTxt; badgesContainer.appendChild(b);
        }
        
        if (m.isQueenConsort) {
            const b = document.createElement('div');
            b.className = "bg-pink-100 text-pink-800 border border-pink-300 px-3 py-1 rounded-full text-xs font-bold";
            b.innerText = "มเหสีคู่บัลลังก์"; badgesContainer.appendChild(b);
        }
        if (m.isHeir) {
            const b = document.createElement('div');
            b.className = "bg-red-100 text-red-800 border border-red-300 px-3 py-1 rounded-full text-xs font-bold";
            b.innerText = `รัชทายาทลำดับที่ ${toThaiNumerals(m.heirOrder)}`; badgesContainer.appendChild(b);
        }
        
        // --- DETAIL MODAL: Show Surname ONLY for the Founder (Per user request) ---
        // "ไม่ต้องแสดงผลป้ายกำกับสกุลที่pop-up ของคู่สมรสและลูกหลานที่สืบสกุล" -> Show only for founder
        if (m.isRoyalSurnameFounder && m.royalSurname) {
            const b = document.createElement('div');
            b.className = "bg-indigo-100 text-indigo-800 border border-indigo-300 px-3 py-1 rounded-full text-xs font-bold";
            b.innerText = `ดันราชสกุล ${m.royalSurname}`; badgesContainer.appendChild(b);
        }
        // --- END DETAIL MODAL SURNAME ---

        const dTerm = m.isAlive ? "มีชีวิต" : getDeathTerm(m);
        document.getElementById('d_status').innerHTML = m.isAlive ? `<span class="text-emerald-600">${dTerm}</span>` : `<span class="text-slate-500">${dTerm}</span>`;
        
        document.getElementById('d_birthYear').innerText = m.birthYear ? toThaiNumerals(m.birthYear) : "-"; 

        document.getElementById('d_spouses_count').innerText = (m.spouseIds||[]).length + " คน";
        document.getElementById('d_umbrella').innerText = m.hasUmbrella ? m.umbrellaType : "-";
        const cr = document.getElementById('d_crown');
        if(m.isMonarch || m.isQueenConsort) { 
            cr.classList.remove('hidden'); 
            cr.className = `fa-solid fa-crown absolute -top-6 left-1/2 -translate-x-1/2 text-3xl drop-shadow-md ${isActiveMonarch ?'text-yellow-400 animate-pulse':'text-slate-500'}`; 
        } else { 
            cr.classList.add('hidden'); 
        }
        
        state.viewRootId = id; 
        document.getElementById('detailModal').classList.add('active');
    }

    // ================= END NEW SPOUSE SELECTION MODAL LOGIC =================
    
function recordTitleHistory(p) {
    if (!p.titleHistory) p.titleHistory = [];
    
    // ดึงค่ารัชกาลปัจจุบัน
    const activeMonarch = state.members.find(m => m.isMonarch && m.isAlive && !m.isExMonarch);
    const currentReign = activeMonarch ? `รัชกาลที่ ${toThaiNumerals(activeMonarch.globalReignNumber)}` : "ก่อนเริ่มรัชกาล/ปฐมวงศ์";
    
    // สร้าง "ลายเซ็นข้อมูล" จากทั้ง 7 ฟิลด์เพื่อตรวจสอบความเปลี่ยนแปลง
    const currentDataSignature = [
        p.relationship,
        p.titlePrefix,
        p.royalRank,
        p.name,
        p.titleSuffix,
        p.kromRank,
        p.kromTitle
    ].join('|');
    
    // ตรวจสอบกับรายการล่าสุดในประวัติ
    const lastEntry = p.titleHistory[p.titleHistory.length - 1];
    const lastSignature = lastEntry ? lastEntry.signature : null;
    
    // ถ้าข้อมูลเปลี่ยนไปจากเดิมแม้แต่นิดเดียว หรือยังไม่มีประวัติเลย ให้บันทึกใหม่
    if (currentDataSignature !== lastSignature) {
        const fullTitle = getFullDisplayTitle(p);
        p.titleHistory.push({ 
            title: fullTitle, 
            reign: currentReign, 
            year: new Date().getFullYear() + 543,
            signature: currentDataSignature // เก็บไว้เพื่อเปรียบเทียบครั้งต่อไป
        });
    }
}

    function handleSavePerson(e) {
        try {
            e.preventDefault();
            const id = document.getElementById('p_id').value || Date.now().toString();
            const isEdit = document.getElementById('p_isEditMode').value === 'true';
            
            const spouseIds = [];
            document.getElementById('p_spouseList').querySelectorAll('li').forEach(li => spouseIds.push(li.dataset.id));

            const oldP = isEdit ? state.members.find(x => x.id === id) : null;

            const isFounder = document.getElementById('p_isSurnameFounder').checked;
            const rank = document.getElementById('p_royalRank').value;
            const commonerInput = document.getElementById('p_commonerSurnameInput').value;
            const royalInput = document.getElementById('p_royalSurnameInput').value;

            let p = {
                id: id,
                name: document.getElementById('p_name').value || '-',
                nickname: document.getElementById('p_nickname').value || '',
                gender: document.querySelector('input[name="gender"]:checked').value,
                isAlive: document.getElementById('p_isAlive').checked,
                relationship: document.getElementById('p_relationship').value,
                titlePrefix: document.getElementById('p_titlePrefix').value || '',
                titleSuffix: document.getElementById('p_titleSuffix').value || '',
                royalRank: document.getElementById('p_royalRank').value,
                kromRank: document.getElementById('p_kromRank').value || '',
                kromTitle: document.getElementById('p_kromTitle').value || '',
                isMonarch: document.getElementById('p_isMonarch').checked,
                isHeir: document.getElementById('p_isHeir').checked,
                heirOrder: document.getElementById('p_heirOrder').value || null,
                isQueenConsort: document.getElementById('p_isQueenConsort').checked,
                useReignName: document.getElementById('p_useReignName').checked,
                reignNameBase: document.getElementById('p_reignNameSelect').value || '',
                globalReignNumber: document.getElementById('p_globalReignNumber').value || null,
                reignStart: document.getElementById('p_reignStart').value || '',
                reignEnd: document.getElementById('p_reignEnd').value || '',
                eraName: document.getElementById('p_eraName').value || '',
                hasUmbrella: document.getElementById('p_hasUmbrella').checked,
                umbrellaType: document.getElementById('p_umbrellaType').value,
                image: document.getElementById('p_imageFinal').value,
                fatherId: document.getElementById('p_fatherId').value || null,
                motherId: document.getElementById('p_motherId').value || null,
                spouseIds: spouseIds,
                hideRoyalRank: document.getElementById('p_hideRoyalRank').checked,
                birthYear: document.getElementById('p_birthYear').value || null,
                
                // --- เพิ่มบรรทัดนี้ลงไปตรงนี้ ---
    titleHistory: oldP?.titleHistory || [], 
    // ----------------------------

    isRoyalSurnameFounder: isFounder,
                // --- Surname Logic Mapping ---
                // isRoyalSurnameFounder: Use checkbox state if checked, otherwise default to false (or keep old if editing)
                isRoyalSurnameFounder: isFounder,

                // royalSurname: Set only if this person is a founder OR inherit from old value for non-founders
                royalSurname: isFounder ? royalInput : (oldP?.royalSurname || ''),
                
                // surname: Set only if rank is 'สามัญชน' and they are NOT a founder (used for *non-royal* commoner lineage display)
                surname: (rank === 'สามัญชน' && !isFounder) ? commonerInput : '', 
                
                // NEW: Hide Surname State
                hideSurname: document.getElementById('p_hideSurname').checked,

                // NEW: Ex-Monarch Flag (Retain old state if editing and Monarch status hasn't changed drastically)
                // MODIFICATION: Preserve old Ex-Monarch state only if isMonarch is still true, otherwise clear it.
                isExMonarch: (oldP?.isExMonarch || false) && (document.getElementById('p_isMonarch').checked || false),

                monarchSpouseContext: (oldP && oldP.monarchSpouseContext && oldP.relationship === document.getElementById('p_relationship').value) ? oldP.monarchSpouseContext : null
            };
            
            // --- NEW: Auto-inherit Royal Surname if not explicitly set and parent has one ---
            // If the person is NOT an explicit founder, inherit the name from the parent lineage
            if (!p.isRoyalSurnameFounder && !p.surname) { // Check that they aren't marked as founder AND aren't a commoner with a commoner surname
                 const father = state.members.find(m => m.id === p.fatherId);
                 const mother = state.members.find(m => m.id === p.motherId);

                 // Priority 1: Father's Royal Surname
                 if (father?.royalSurname) {
                     p.royalSurname = father.royalSurname;
                 } 
                 // Priority 2: Mother's Royal Surname (if father doesn't have one or is commoner)
                 else if (mother?.royalSurname) {
                     p.royalSurname = mother.royalSurname;
                 }
                 // Priority 3: Spouse's Royal Surname (for new spouse added)
                 else if (!isEdit && spouseIds.length > 0) {
                      const primarySpouse = state.members.find(s => s.id === spouseIds[0]);
                      if (primarySpouse?.royalSurname) {
                          p.royalSurname = primarySpouse.royalSurname;
                      }
                 }
            }


            if (p.isMonarch) {
                p.kromRank = '';
                p.kromTitle = '';
                p.isExMonarch = false; // Cannot edit to be Ex-Monarch while setting as Monarch
            } else if (oldP?.isMonarch) {
                 // If changing from Monarch (isMonarch=true) to non-Monarch (isMonarch=false) during edit, it should probably be an abdication or a death process, not a simple form edit.
                 // We preserve oldExMonarch state here to allow a deceased Ex-Monarch to be edited.
                 p.isExMonarch = oldP.isExMonarch; 
            }
            
            p = checkConsortMotherhood(p);

            if(isEdit) {
                const idx = state.members.findIndex(m => m.id === id);
                if(idx !== -1) {
                    const old = state.members[idx];
                    old.spouseIds.forEach(sid => { if(!spouseIds.includes(sid)) { const s = state.members.find(x => x.id === sid); if(s) s.spouseIds = s.spouseIds.filter(x => x !== id); } });
                    state.members[idx] = p;
                }
            } else {
                state.members.push(p);
            }

            spouseIds.forEach(sid => { const s = state.members.find(x => x.id === sid); if(s && !s.spouseIds.includes(id)) s.spouseIds.push(id); });

            if(p.isMonarch && p.gender === 'M') {
                const selectedQueenId = document.getElementById('p_queenSelectForKing').value;
                p.spouseIds.forEach(sid => {
                    const s = state.members.find(m => m.id === sid);
                    if(s) s.isQueenConsort = false;
                });
                if(selectedQueenId) {
                    const q = state.members.find(m => m.id === selectedQueenId);
                    if(q) q.isQueenConsort = true;
                }
            }
            
            if (!isEdit && (p.fatherId || p.motherId)) {
                [p.fatherId, p.motherId].forEach(parentId => {
                    if (parentId) {
                        const parent = state.members.find(m => m.id === parentId);
                        if (parent) {
                            const updatedParent = checkConsortMotherhood(parent);
                            if (updatedParent.titlePrefix !== parent.titlePrefix) {
                                const idx = state.members.findIndex(x => x.id === parentId);
                                if(idx !== -1) state.members[idx] = updatedParent;
                            }
                        }
                    }
                });
            }
saveState();
recordTitleHistory(p); // บันทึกยศใหม่เข้าทำเนียบ (ถ้ามีการเปลี่ยนแปลง)
saveState(); // บันทึกข้อมูลลงฐานข้อมูล
            saveState();
            closeModal('personModal');
            if(p.isMonarch && !isEdit && p.isAlive) showFantasyPopup(p);
            refreshAllDisplays(); 
            showToast('บันทึกข้อมูลเรียบร้อย');
        } catch (err) {
            console.error(err);
            alert('เกิดข้อผิดพลาดในการบันทึก: ' + err.message);
        }
    }

    function openModal(d={}, edit=false, contextTitle=null) {
        try {
            const f = document.getElementById('personForm'); f.reset();
            document.getElementById('p_isEditMode').value = edit;
            const titleEl = document.getElementById('modalTitle');
            if(contextTitle) { titleEl.innerHTML = `<i class="fa-solid fa-wand-magic-sparkles mr-2"></i>ข้อมูลบุคคล (${contextTitle})`; } 
            else { titleEl.innerHTML = `<i class="fa-solid fa-wand-magic-sparkles mr-2"></i>ข้อมูลบุคคล`; }
            if (!edit && !d.gender) { const mRadio = document.querySelector('input[name="gender"][value="M"]'); if(mRadio) mRadio.checked = true; } 
            else if(d.gender) { document.querySelector(`input[name="gender"][value="${d.gender}"]`).checked = true; }
            
            // --- NEW RANK CALCULATION LOGIC ---
            let calculatedRank = {};
            if (!edit && (d.fatherId || d.motherId)) {
                const currentMonarch = state.members.find(m => m.isMonarch && m.isAlive && !m.isExMonarch);
                const gender = d.gender || document.querySelector('input[name="gender"]:checked').value;
                
                if (currentMonarch && (d.fatherId === currentMonarch.id || d.motherId === currentMonarch.id)) {
                    const monarchParentId = d.fatherId === currentMonarch.id ? d.fatherId : d.motherId;
                    const otherParentId = d.fatherId === currentMonarch.id ? d.motherId : d.fatherId;
                    calculatedRank = calculateChildRank(monarchParentId, otherParentId, gender);
                } else {
                    calculatedRank = calculateChildRankGeneric(d.fatherId, d.motherId, gender);
                }
                
                // Apply calculated rank and names
                d.royalRank = calculatedRank.royalRank;
                d.titlePrefix = calculatedRank.titlePrefix;
                d.relationship = calculatedRank.relationship;
                // If it's a new person, use the calculated surname for display
                d.royalSurname = d.royalSurname || calculatedRank.royalSurname; 
                d.surname = d.surname || calculatedRank.surname;
            }
            // --- END NEW RANK CALCULATION LOGIC ---
            
            document.getElementById('p_royalRank').value = d.royalRank || 'สามัญชน';
            document.getElementById('p_hideRoyalRank').checked = !!d.hideRoyalRank;
            if(!edit) { updateAutoId(); } else { document.getElementById('p_id').value = d.id || ''; }
            document.getElementById('p_name').value = d.name || '';
            document.getElementById('p_nickname').value = d.nickname || '';
            document.getElementById('p_isAlive').checked = d.isAlive !== false;
            
            document.getElementById('p_birthYear').value = d.birthYear || ''; 
            
            // NEW: Load surname fields and toggles
            // A person is marked as founder ONLY if their saved data explicitly says so (d.isRoyalSurnameFounder).
            // This prevents descendants/spouses who auto-inherit the name from being marked as founders.
            const isFounder = !!d.isRoyalSurnameFounder;
            document.getElementById('p_isSurnameFounder').checked = isFounder;
            document.getElementById('p_royalSurnameInput').value = d.royalSurname || ''; // Shows inherited royal surname
            document.getElementById('p_commonerSurnameInput').value = d.surname || '';
            // NEW: Hide Surname Checkbox
            document.getElementById('p_hideSurname').checked = !!d.hideSurname;
            
            populateRelSelect(d.relationship);
            updatePrefixOptions(d.titlePrefix);
            updateSuffixOptions(d.titleSuffix);
            document.getElementById('p_fatherId').value = d.fatherId || '';
            document.getElementById('p_fatherSearch').value = d.fatherId ? (state.members.find(x=>x.id==d.fatherId)?.name || d.fatherId) : '';
            document.getElementById('p_motherId').value = d.motherId || '';
            document.getElementById('p_motherSearch').value = d.motherId ? (state.members.find(x=>x.id==d.motherId)?.name || d.motherId) : '';
            
            // MODIFICATION: The checkbox value is based directly on the historical data (d.isMonarch)
            document.getElementById('p_isMonarch').checked = !!d.isMonarch;
            
            document.getElementById('p_useReignName').checked = !!d.useReignName;
            populateReignSelect(d.reignNameBase);
            if(!edit && d.isMonarch === undefined) {
                 const monarchs = state.members.filter(x => x.isMonarch);
                 const maxGlobal = Math.max(0, ...monarchs.map(x => parseInt(x.globalReignNumber||0)));
                 document.getElementById('p_globalReignNumber').value = maxGlobal + 1;
            } else { document.getElementById('p_globalReignNumber').value = d.globalReignNumber || ''; }
            document.getElementById('p_reignStart').value = d.reignStart || '';
            document.getElementById('p_reignEnd').value = d.reignEnd || '';
            document.getElementById('p_eraName').value = d.eraName || '';
            toggleMonarch();
            document.getElementById('p_isHeir').checked = !!d.isHeir;
            document.getElementById('p_heirOrder').value = d.heirOrder || '';
            toggleHeirOrder();
            document.getElementById('p_isQueenConsort').checked = !!d.isQueenConsort;
            document.getElementById('p_hasUmbrella').checked = !!d.hasUmbrella;
            document.getElementById('p_umbrellaType').value = d.umbrellaType || 'ตรีดลเศวตฉัตร';
            toggleUmbrella();
            document.getElementById('p_kromRank').value = d.kromRank || '';
            document.getElementById('p_kromTitle').value = d.kromTitle || '';
            toggleKrom();
            const ul = document.getElementById('p_spouseList'); ul.innerHTML = '';
            (d.spouseIds || []).forEach(sid => { const s = state.members.find(x => x.id === sid); if(s) addSpouseLi(s); });
            document.getElementById('p_imagePreview').src = d.image || (d.gender==='F'?DEFAULT_IMG_FEMALE:DEFAULT_IMG_MALE);
            document.getElementById('p_imageFinal').value = d.image || '';
            
            if (d.fatherOptions || d.motherOptions) {
                updateDatalists(d.id, d.fatherOptions, d.motherOptions);
            } else {
                updateDatalists(d.id);
            }

            updateQueenConsortSelector(d);
            setTimeout(checkQueenConsortEligible, 100);
            toggleSurnameFields(); // Initialize visibility of new fields
            document.getElementById('personModal').classList.add('active');
        } catch(e) { console.error(e); }
    }

    function openAddRootModal() { openModal({}); }
    function editCurrent() { closeModal('detailModal'); openModal(state.members.find(m=>m.id===window.curPID), true); }
    
    function toggleDeath() { 
        const p = state.members.find(m=>m.id===window.curPID); 
        const wasActiveMonarch = p.isMonarch && p.isAlive && !p.isExMonarch; // Check before flipping isAlive
        
        p.isAlive = !p.isAlive;
        
        if(!p.isAlive) { 
            
            // If they were the active monarch (and not ex-monarch), handle succession
            if (wasActiveMonarch) {
                handleMonarchDeath(p); 
            } else {
                 // Context is cleared because it was set on abdication/death (and they are now deceased)
                 p.monarchSpouseContext = null; 
                 // If a former monarch who abdicated (ExMonarch=true) dies, remove ExMonarch flag
                 if (p.isMonarch) p.isExMonarch = false;
            }
            if (p.isHeir) handleHeirDeath(p); 

        } else {
            p.monarchSpouseContext = null; 
        }
        
        if (p.gender === 'F' && (p.relationship||'').includes('บาทบริจาริกา')) {
            const updatedP = checkConsortMotherhood(p);
            p.titlePrefix = updatedP.titlePrefix; 
        }
        saveState(); showDetail(p.id); refreshAllDisplays(); 
    }
    
    function deleteCurrent() {
        if(!confirm('ยืนยันการลบ?')) return;
        const id = window.curPID;
        state.members = state.members.filter(m => m.id !== id);
        state.members.forEach(m => {
            if(m.fatherId === id) m.fatherId = null;
            if(m.motherId === id) m.motherId = null;
            m.spouseIds = m.spouseIds.filter(sid => sid !== id);
        });
        const possibleMothers = state.members.filter(m => (m.relationship||'').includes('บาทบริจาริกา') && m.gender === 'F');
        possibleMothers.forEach(m => {
            const updatedM = checkConsortMotherhood(m);
            if (updatedM.titlePrefix !== m.titlePrefix) {
                const idx = state.members.findIndex(x => x.id === m.id);
                if(idx !== -1) state.members[idx] = updatedM;
            }
        });
        
        saveState(); closeModal('detailModal'); refreshAllDisplays();
    }

    function openRelationshipModal() {
        document.getElementById('rel_input_a').value = '';
        document.getElementById('rel_input_b').value = '';
        document.getElementById('rel_id_a').value = '';
        document.getElementById('rel_id_b').value = '';
        document.getElementById('rel_img_a').src = '';
        document.getElementById('rel_img_b').src = '';
        
        const dl = document.getElementById('relOptions');
        dl.innerHTML = '';
        state.members.forEach(m => {
            const op = document.createElement('option');
            op.value = `${m.id} : ${m.name}`;
            dl.appendChild(op);
        });
        
        document.getElementById('relationshipModal').classList.add('active');
    }

    function updateRelPreview(side) {
        const input = document.getElementById(`rel_input_${side}`).value;
        const match = input.match(/^(.*?)\s*:\s*(.*)$/);
        let id = null;
        if(match) {
            id = match[1].trim();
        } else {
             const m = state.members.find(x => x.name === input.trim());
             if (m) id = m.id;
        }

        if(id) {
            const m = state.members.find(x => x.id === id);
            if(m) {
                document.getElementById(`rel_id_${side}`).value = id;
                document.getElementById(`rel_img_${side}`).src = m.image || (m.gender==='M'?DEFAULT_IMG_MALE:DEFAULT_IMG_FEMALE);
                document.getElementById(`rel_img_${side}`).classList.remove('opacity-50');
                return;
            }
        }
        document.getElementById(`rel_id_${side}`).value = '';
        document.getElementById(`rel_img_${side}`).src = '';
        document.getElementById(`rel_img_${side}`).classList.add('opacity-50');
    }

    function calculateRelationship() {
        const idA = document.getElementById('rel_id_a').value;
        const idB = document.getElementById('rel_id_b').value;
        
        if(!idA || !idB) { showToast("กรุณาเลือกบุคคลให้ครบทั้งสองคน"); return; }
        if(idA === idB) { showToast("โปรดเลือกบุคคลที่แตกต่างกัน"); return; }
        
        const path = findRelationshipPath(idA, idB);
        
        if(!path) {
            showToast("ไม่พบความสัมพันธ์ระหว่างสองคนนี้");
            return;
        }

        closeModal('relationshipModal');
        state.highlightIds = [idA, idB];
        const midId = path[Math.floor(path.length/2)];
        state.viewRootId = midId; 
        state.treeViewType = 'all'; 
        
        saveState();
        renderTree();
        resetView();
        showToast("แสดงเส้นทางความสัมพันธ์แล้ว");
        setTimeout(() => { state.highlightIds = []; renderTree(); }, 5000);
    }

    function findRelationshipPath(startId, endId) {
        const queue = [[startId]];
        const visited = new Set();
        visited.add(startId);
        
        while (queue.length > 0) {
            const path = queue.shift();
            const node = path[path.length - 1];
            
            if (node === endId) return path;
            
            const neighbors = [];
            const m = state.members.find(x => x.id === node);
            if(m) {
                if(m.fatherId) neighbors.push(m.fatherId);
                if(m.motherId) neighbors.push(m.motherId);
                if(m.spouseIds) neighbors.push(...m.spouseIds);
                state.members.filter(c => c.fatherId === node || c.motherId === node).forEach(c => neighbors.push(c.id));
            }
            
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    const newPath = [...path, neighbor];
                    queue.push(newPath);
                }
            }
        }
        return null;
    }

    function setAsRoot(id) { 
        state.viewRootId = id; 
        
        // NEW LOGIC: Auto-switch to Royal Surname View if the person belongs to one
        const founderId = getSurnameFounderForPerson(id);
        
        if (founderId) {
            state.treeViewType = 'royalSurname';
            state.currentSurnameRootId = founderId;
            // Update the dropdown immediately for visual feedback
            document.getElementById('treeViewMode').value = 'royalSurname';
        } else if (state.treeViewType === 'royalSurname') {
            // If they don't have a surname, but we were in surname view, reset to 'all'
             state.treeViewType = 'all';
             document.getElementById('treeViewMode').value = 'all';
        }
        
        saveState(); 
        closeModal('detailModal'); 
        renderTree(); 
        resetView(); 
    }
    function focusOnPerson(val) { 
        const id = val.split(':')[0].trim(); 
        if(state.members.find(m => m.id === id)) { 
            state.viewRootId = id; 
            renderTree(); 
        } 
    }
    function focusOnMonarch() { const m = state.members.find(x => x.isMonarch && x.isAlive && !x.isExMonarch); if(m) { state.viewRootId = m.id; renderTree(); resetView(); } }
    function populateSearchLists() { const dl = document.getElementById('focusOptions'); dl.innerHTML = ''; state.members.forEach(m => { const op = document.createElement('option'); op.value = `${m.id} : ${m.name}`; dl.appendChild(op); }); }
    function openAddParentModal(childId) { closeModal('detailModal'); openModal({}); showToast("สร้างบุคคลใหม่ แล้วนำ ID ไปใส่ในช่อง พระบิดา/พระมารดา ของลูก"); }
    
    // NOTE: openAddSpouseModal is now openSpouseSelectionModal
    // function openAddSpouseModal(id) { closeModal('detailModal'); const m = state.members.find(x => x.id === id); openModal({ spouseIds: [id], gender: m.gender==='M'?'F':'M' }, false, `คู่สมรสของ ${m.name}`); }
    
    function openAddChildModal(id) { 
        closeModal('detailModal'); 
        const m = state.members.find(x => x.id === id); 
        
        const defaults = m.gender === 'M' ? { fatherId: id } : { motherId: id }; 
        
        const spouseObjects = (m.spouseIds || [])
            .map(sid => state.members.find(x => x.id === sid))
            .filter(s => s);
            
        let otherParentId = null;
        let filteredParentList = []; 
        
        if (spouseObjects.length > 0) {
            const requiredGender = m.gender === 'M' ? 'F' : 'M';
            filteredParentList = spouseObjects.filter(s => s.gender === requiredGender);

            if (filteredParentList.length === 1) {
                otherParentId = filteredParentList[0].id;
            }
        }
        
        if (otherParentId) {
            if (m.gender === 'M') {
                defaults.motherId = otherParentId;
            } else {
                defaults.fatherId = otherParentId;
            }
        }

        if (m.gender === 'M') {
             defaults.motherOptions = filteredParentList;
        } else {
             defaults.fatherOptions = filteredParentList;
        }

        openModal(defaults, false, `ลูกของ ${m.name}`); 
        
        const otherInputId = m.gender === 'M' ? 'p_motherSearch' : 'p_fatherSearch';
        const type = m.gender === 'M' ? 'mother' : 'father';
        const inputEl = document.getElementById(otherInputId);
        if(inputEl) {
            inputEl.onchange = function() {
                validateParent(type);
                setTimeout(() => {
                    const baseTitle = `ลูกของ ${m.name}`;
                    const otherParent = state.members.find(x => x.id === document.getElementById(type==='mother'?'p_motherId':'p_fatherId').value);
                    const newTitle = otherParent ? `${baseTitle} กับ ${otherParent.name}` : baseTitle;
                    document.getElementById('modalTitle').innerHTML = `<i class="fa-solid fa-wand-magic-sparkles mr-2"></i>เพิ่มข้อมูลบุคคล (${newTitle})`;
                }, 100);
            };
            if (otherParentId) {
                const autoSelectedParent = state.members.find(x => x.id === otherParentId);
                if (autoSelectedParent) {
                    inputEl.value = autoSelectedParent.name;
                }
            }
        }
    }
    
    function toggleReignName() { const u = document.getElementById('p_useReignName').checked; document.getElementById('p_reignNameSelect').classList.toggle('hidden', !u); document.getElementById('p_autoReignNameNumber').classList.toggle('hidden', !u); }
    function toggleHeirOrder() { const h = document.getElementById('p_isHeir').checked; document.getElementById('p_heirOrder').classList.toggle('hidden', !h); }
    function toggleUmbrella() { const h = document.getElementById('p_hasUmbrella').checked; document.getElementById('p_umbrellaType').classList.toggle('hidden', !h); }
    function toggleKrom() { const v = document.getElementById('p_kromRank').value; document.getElementById('p_kromTitle').classList.toggle('hidden', !v); }
    function populateReignSelect(selVal) { const s = document.getElementById('p_reignNameSelect'); s.innerHTML = ''; state.reignNames.forEach(n => s.innerHTML += `<option value="${n}">${n}</option>`); if(selVal) s.value = selVal; }
  // 1. ฟังก์ชันเลือกความสัมพันธ์ (ดึงลำดับตามที่คุณจัดไว้ในหน้าจัดการยศ)
function populateRelSelect(v) { 
    const s = document.getElementById('p_relationship'); 
    s.innerHTML = '<option value="">- เลือกความสัมพันธ์ -</option>'; 
    
    // ดึงลำดับจากสิ่งที่คุณลากวางไว้ในหน้าจัดการยศมาแสดง
    Object.keys(state.hierarchy).forEach(rel => {
        const op = new Option(rel, rel);
        s.add(op);
    });

    if(v) s.value = v; 
    s.onchange = () => updatePrefixOptions();
}

// 2. ฟังก์ชันเลือกคำนำหน้า (จะกรองมาเฉพาะที่อยู่ในหมวดความสัมพันธ์นั้น)
function updatePrefixOptions(v) { 
    const rel = document.getElementById('p_relationship').value; 
    const s = document.getElementById('p_titlePrefix'); 
    s.innerHTML = '<option value="">- เลือกคำนำหน้า -</option>'; 
    
    if(rel && state.hierarchy[rel]) {
        state.hierarchy[rel].prefixes.forEach(p => {
            s.add(new Option(p, p));
        });
    }
    
    if(v) s.value = v; 
    s.onchange = () => {
        updateSuffixOptions();
        checkQueenConsortEligible(); 
    };
    
    updateSuffixOptions(); 
}

// 3. ฟังก์ชันเลือกสร้อยพระนาม (จะกรองมาเฉพาะที่คู่กับคำนำหน้านั้น)
function updateSuffixOptions(v) { 
    const rel = document.getElementById('p_relationship').value; 
    const pre = document.getElementById('p_titlePrefix').value; 
    const s = document.getElementById('p_titleSuffix'); 
    s.innerHTML = '<option value="">- ไม่มีสร้อย -</option>'; 
    
    if(rel && pre && state.hierarchy[rel] && state.hierarchy[rel].suffixes[pre]) {
        state.hierarchy[rel].suffixes[pre].forEach(x => {
            s.add(new Option(x, x));
        });
    }
    
    if(v) s.value = v; 
}
    
    function updateDatalists(selfId, filteredFatherList, filteredMotherList) { 
        const fo = document.getElementById('fatherOptions'); fo.innerHTML=''; 
        const mo = document.getElementById('motherOptions'); mo.innerHTML=''; 
        const so = document.getElementById('spouseOptions'); so.innerHTML=''; 
        
        let fatherCandidates = filteredFatherList || state.members.filter(m => m.gender === 'M');
        let motherCandidates = filteredMotherList || state.members.filter(m => m.gender === 'F');

        fatherCandidates.forEach(m => {
            if(m.id === selfId) return; 
            const op = document.createElement('option'); 
            op.value = m.id; 
            op.innerText = m.name; 
            fo.appendChild(op);
        });

        motherCandidates.forEach(m => {
            if(m.id === selfId) return; 
            const op = document.createElement('option'); 
            op.value = m.id; 
            op.innerText = m.name; 
            mo.appendChild(op);
        });
        
        state.members.forEach(m => { 
            if(m.id === selfId) return; 
            const op = `<option value="${m.id}">${m.name}</option>`;
            so.innerHTML += op; 
        });
    }

    function validateParent(type) { const i = document.getElementById(type==='father'?'p_fatherSearch':'p_motherSearch'); const h = document.getElementById(type==='father'?'p_fatherId':'p_motherId'); const val = i.value.trim(); const found = state.members.find(m => m.id === val || m.name === val); if(found) { h.value = found.id; i.value = found.name; } else { h.value = ''; } }
    function addSpouse() { 
        const val = document.getElementById('p_spouseSearch').value; 
        const m = state.members.find(x => x.id === val || x.name === val); 
        if(m) { 
            const ul = document.getElementById('p_spouseList'); 
            if([...ul.children].some(li => li.dataset.id === m.id)) { showToast("มีรายชื่อนี้อยู่แล้ว"); return; }
            addSpouseLi(m); 
            document.getElementById('p_spouseSearch').value = ''; 
            updateQueenConsortSelector(); 
        } 
    }
    function addSpouseLi(m) { const ul = document.getElementById('p_spouseList'); const li = document.createElement('li'); li.className = "bg-rose-50 text-rose-600 px-2 py-1 rounded-lg flex items-center gap-2 border border-rose-100"; li.dataset.id = m.id; li.innerHTML = `<span>${m.name}</span> <button type="button" onclick="this.parentElement.remove(); updateQueenConsortSelector()" class="text-rose-300 hover:text-red-500">×</button>`; ul.appendChild(li); }
    function handleImageUpload(i){ const r=new FileReader(); r.onload=e=>{ document.getElementById('p_imagePreview').src=e.target.result; document.getElementById('p_imageFinal').value=e.target.result; }; if(i.files[0]) r.readAsDataURL(i.files[0]); }
    function updateDefaultImage(){ if(!document.getElementById('p_imageFinal').value) document.getElementById('p_imagePreview').src = document.querySelector('input[name="gender"]:checked').value==='M'?DEFAULT_IMG_MALE:DEFAULT_IMG_FEMALE; }
    function closeModal(id) { document.getElementById(id).classList.remove('active'); }
    function showToast(msg) { const c = document.getElementById('toast-container'); const t = document.createElement('div'); t.className = 'toast'; t.innerHTML = msg; c.appendChild(t); setTimeout(()=>t.remove(), 3000); }
    function copyToClipboard(t){ const ta=document.createElement('textarea'); ta.value=t; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); showToast('คัดลอก ID แล้ว'); }
    function setTheme(t) { document.body.setAttribute('data-theme', t); state.currentTheme=t; saveState(); }

    // ================= PAN & ZOOM FIXES (VERIFIED SMOOTH DRAGGING) =================
    function setupPanZoom() { 
        const c = document.getElementById('canvas-container'); 
        
        // MOUSE DOWN: Start Dragging, prevent default browser behavior (e.g., text selection)
        c.addEventListener('mousedown',e=>{ 
            // Only start drag if clicking on the main SVG or the viewport group (not a node or control)
            if(e.target.id!=='main-svg' && e.target.id!=='viewport-group') return; 
            e.preventDefault(); 
            state.isDragging=true; 
            state.startX=e.clientX-state.panX; 
            state.startY=e.clientY-state.panY; 
        }); 
        
        // MOUSE UP: Stop Dragging
        window.addEventListener('mouseup',()=>{
            state.isDragging=false;
        }); 
        
        // MOUSE MOVE: Dragging action
        window.addEventListener('mousemove',e=>{ 
            if(!state.isDragging)return; 
            e.preventDefault(); // Prevents cursor change/jerkiness during drag (fixes lag/bug)
            state.panX=e.clientX-state.startX; 
            state.panY=e.clientY-state.startY; 
            updateTrans(); 
        }); 
        
        // WHEEL: Zooming
        c.addEventListener('wheel',e=>{ 
            e.preventDefault(); 
            state.zoom = Math.min(Math.max(0.1, state.zoom + (-e.deltaY*0.001)), 5); 
            updateTrans(); 
        }, {passive:false}); 
    }

    function updateTrans(){ document.getElementById('viewport-group').setAttribute("transform", `translate(${state.panX},${state.panY}) scale(${state.zoom})`); }
    function zoomIn(){ state.zoom *= 1.2; updateTrans(); }
    function zoomOut(){ state.zoom /= 1.2; updateTrans(); }
    function resetView(){ 
        // Get viewport size
        const canvas = document.getElementById('canvas-container');
        const vw = canvas.clientWidth;
        
        state.zoom=1; 
        state.panX=vw/2 - BASE_CONFIG.nodeWidth/2; 
        state.panY=50; 
        updateTrans(); 
    }
    function toggleOrientation(){ state.isHorizontal=!state.isHorizontal; renderTree(); resetView(); }
   function showHistoryModal(id) {
    const p = state.members.find(m => m.id === id);
    if (!p) return;
    
    if (!p.titleHistory || p.titleHistory.length === 0) recordTitleHistory(p);
    
    const list = document.getElementById('historyList');
    list.innerHTML = '';
    
    p.titleHistory.forEach((h, index) => {
        const item = document.createElement('div');
        item.className = "relative pl-8 border-l-2 border-slate-100 pb-4 last:pb-0 group";
        item.innerHTML = `
            <div class="absolute -left-[9px] top-0 w-4 h-4 rounded-full bg-slate-200 border-2 border-white"></div>
            <div class="flex justify-between items-start">
                <div class="flex-1">
                    <div class="text-[10px] font-bold px-2 py-0.5 rounded bg-blue-50 text-blue-500 inline-block mb-1">
                        สมัย${h.reign}
                    </div>
                    <div class="text-sm font-bold text-slate-700 leading-snug">${h.title}</div>
           
                </div>
                <button onclick="deleteHistoryEntry('${p.id}', ${index})" class="opacity-0 group-hover:opacity-100 p-1.5 text-red-300 hover:text-red-500 transition-all">
                    <i class="fa-solid fa-trash-can text-xs"></i>
                </button>
            </div>
        `;
        list.appendChild(item);
    });
    
    document.getElementById('historyModal').classList.add('active');
}
function deleteHistoryEntry(personId, index) {
    if (!confirm("ต้องการลบรายการประวัตินี้ใช่หรือไม่?")) return;

    const p = state.members.find(m => m.id === personId);
    if (p && p.titleHistory) {
        p.titleHistory.splice(index, 1);
        saveState();
        showHistoryModal(personId); // รีเฟรชหน้าต่างทำเนียบ
        showToast("ลบข้อมูลเรียบร้อย");
    }
}

</script>
</body>
</html>
